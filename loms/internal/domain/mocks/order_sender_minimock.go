package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/domain.OrderSender -o ./mocks/order_sender_minimock.go -n OrderSenderMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderSenderMock implements domain.OrderSender
type OrderSenderMock struct {
	t minimock.Tester

	funcAddErrorHandler          func(ctx context.Context, onError func(orderID int64, status string))
	inspectFuncAddErrorHandler   func(ctx context.Context, onError func(orderID int64, status string))
	afterAddErrorHandlerCounter  uint64
	beforeAddErrorHandlerCounter uint64
	AddErrorHandlerMock          mOrderSenderMockAddErrorHandler

	funcAddSuccessHandler          func(ctx context.Context, onSuccess func(orderID int64, status string))
	inspectFuncAddSuccessHandler   func(ctx context.Context, onSuccess func(orderID int64, status string))
	afterAddSuccessHandlerCounter  uint64
	beforeAddSuccessHandlerCounter uint64
	AddSuccessHandlerMock          mOrderSenderMockAddSuccessHandler

	funcSendOrderStatus          func(ctx context.Context, orderID int64, status string)
	inspectFuncSendOrderStatus   func(ctx context.Context, orderID int64, status string)
	afterSendOrderStatusCounter  uint64
	beforeSendOrderStatusCounter uint64
	SendOrderStatusMock          mOrderSenderMockSendOrderStatus
}

// NewOrderSenderMock returns a mock for domain.OrderSender
func NewOrderSenderMock(t minimock.Tester) *OrderSenderMock {
	m := &OrderSenderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddErrorHandlerMock = mOrderSenderMockAddErrorHandler{mock: m}
	m.AddErrorHandlerMock.callArgs = []*OrderSenderMockAddErrorHandlerParams{}

	m.AddSuccessHandlerMock = mOrderSenderMockAddSuccessHandler{mock: m}
	m.AddSuccessHandlerMock.callArgs = []*OrderSenderMockAddSuccessHandlerParams{}

	m.SendOrderStatusMock = mOrderSenderMockSendOrderStatus{mock: m}
	m.SendOrderStatusMock.callArgs = []*OrderSenderMockSendOrderStatusParams{}

	return m
}

type mOrderSenderMockAddErrorHandler struct {
	mock               *OrderSenderMock
	defaultExpectation *OrderSenderMockAddErrorHandlerExpectation
	expectations       []*OrderSenderMockAddErrorHandlerExpectation

	callArgs []*OrderSenderMockAddErrorHandlerParams
	mutex    sync.RWMutex
}

// OrderSenderMockAddErrorHandlerExpectation specifies expectation struct of the OrderSender.AddErrorHandler
type OrderSenderMockAddErrorHandlerExpectation struct {
	mock   *OrderSenderMock
	params *OrderSenderMockAddErrorHandlerParams

	Counter uint64
}

// OrderSenderMockAddErrorHandlerParams contains parameters of the OrderSender.AddErrorHandler
type OrderSenderMockAddErrorHandlerParams struct {
	ctx     context.Context
	onError func(orderID int64, status string)
}

// Expect sets up expected params for OrderSender.AddErrorHandler
func (mmAddErrorHandler *mOrderSenderMockAddErrorHandler) Expect(ctx context.Context, onError func(orderID int64, status string)) *mOrderSenderMockAddErrorHandler {
	if mmAddErrorHandler.mock.funcAddErrorHandler != nil {
		mmAddErrorHandler.mock.t.Fatalf("OrderSenderMock.AddErrorHandler mock is already set by Set")
	}

	if mmAddErrorHandler.defaultExpectation == nil {
		mmAddErrorHandler.defaultExpectation = &OrderSenderMockAddErrorHandlerExpectation{}
	}

	mmAddErrorHandler.defaultExpectation.params = &OrderSenderMockAddErrorHandlerParams{ctx, onError}
	for _, e := range mmAddErrorHandler.expectations {
		if minimock.Equal(e.params, mmAddErrorHandler.defaultExpectation.params) {
			mmAddErrorHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddErrorHandler.defaultExpectation.params)
		}
	}

	return mmAddErrorHandler
}

// Inspect accepts an inspector function that has same arguments as the OrderSender.AddErrorHandler
func (mmAddErrorHandler *mOrderSenderMockAddErrorHandler) Inspect(f func(ctx context.Context, onError func(orderID int64, status string))) *mOrderSenderMockAddErrorHandler {
	if mmAddErrorHandler.mock.inspectFuncAddErrorHandler != nil {
		mmAddErrorHandler.mock.t.Fatalf("Inspect function is already set for OrderSenderMock.AddErrorHandler")
	}

	mmAddErrorHandler.mock.inspectFuncAddErrorHandler = f

	return mmAddErrorHandler
}

// Return sets up results that will be returned by OrderSender.AddErrorHandler
func (mmAddErrorHandler *mOrderSenderMockAddErrorHandler) Return() *OrderSenderMock {
	if mmAddErrorHandler.mock.funcAddErrorHandler != nil {
		mmAddErrorHandler.mock.t.Fatalf("OrderSenderMock.AddErrorHandler mock is already set by Set")
	}

	if mmAddErrorHandler.defaultExpectation == nil {
		mmAddErrorHandler.defaultExpectation = &OrderSenderMockAddErrorHandlerExpectation{mock: mmAddErrorHandler.mock}
	}

	return mmAddErrorHandler.mock
}

// Set uses given function f to mock the OrderSender.AddErrorHandler method
func (mmAddErrorHandler *mOrderSenderMockAddErrorHandler) Set(f func(ctx context.Context, onError func(orderID int64, status string))) *OrderSenderMock {
	if mmAddErrorHandler.defaultExpectation != nil {
		mmAddErrorHandler.mock.t.Fatalf("Default expectation is already set for the OrderSender.AddErrorHandler method")
	}

	if len(mmAddErrorHandler.expectations) > 0 {
		mmAddErrorHandler.mock.t.Fatalf("Some expectations are already set for the OrderSender.AddErrorHandler method")
	}

	mmAddErrorHandler.mock.funcAddErrorHandler = f
	return mmAddErrorHandler.mock
}

// AddErrorHandler implements domain.OrderSender
func (mmAddErrorHandler *OrderSenderMock) AddErrorHandler(ctx context.Context, onError func(orderID int64, status string)) {
	mm_atomic.AddUint64(&mmAddErrorHandler.beforeAddErrorHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddErrorHandler.afterAddErrorHandlerCounter, 1)

	if mmAddErrorHandler.inspectFuncAddErrorHandler != nil {
		mmAddErrorHandler.inspectFuncAddErrorHandler(ctx, onError)
	}

	mm_params := &OrderSenderMockAddErrorHandlerParams{ctx, onError}

	// Record call args
	mmAddErrorHandler.AddErrorHandlerMock.mutex.Lock()
	mmAddErrorHandler.AddErrorHandlerMock.callArgs = append(mmAddErrorHandler.AddErrorHandlerMock.callArgs, mm_params)
	mmAddErrorHandler.AddErrorHandlerMock.mutex.Unlock()

	for _, e := range mmAddErrorHandler.AddErrorHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddErrorHandler.AddErrorHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddErrorHandler.AddErrorHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddErrorHandler.AddErrorHandlerMock.defaultExpectation.params
		mm_got := OrderSenderMockAddErrorHandlerParams{ctx, onError}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddErrorHandler.t.Errorf("OrderSenderMock.AddErrorHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddErrorHandler.funcAddErrorHandler != nil {
		mmAddErrorHandler.funcAddErrorHandler(ctx, onError)
		return
	}
	mmAddErrorHandler.t.Fatalf("Unexpected call to OrderSenderMock.AddErrorHandler. %v %v", ctx, onError)

}

// AddErrorHandlerAfterCounter returns a count of finished OrderSenderMock.AddErrorHandler invocations
func (mmAddErrorHandler *OrderSenderMock) AddErrorHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddErrorHandler.afterAddErrorHandlerCounter)
}

// AddErrorHandlerBeforeCounter returns a count of OrderSenderMock.AddErrorHandler invocations
func (mmAddErrorHandler *OrderSenderMock) AddErrorHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddErrorHandler.beforeAddErrorHandlerCounter)
}

// Calls returns a list of arguments used in each call to OrderSenderMock.AddErrorHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddErrorHandler *mOrderSenderMockAddErrorHandler) Calls() []*OrderSenderMockAddErrorHandlerParams {
	mmAddErrorHandler.mutex.RLock()

	argCopy := make([]*OrderSenderMockAddErrorHandlerParams, len(mmAddErrorHandler.callArgs))
	copy(argCopy, mmAddErrorHandler.callArgs)

	mmAddErrorHandler.mutex.RUnlock()

	return argCopy
}

// MinimockAddErrorHandlerDone returns true if the count of the AddErrorHandler invocations corresponds
// the number of defined expectations
func (m *OrderSenderMock) MinimockAddErrorHandlerDone() bool {
	for _, e := range m.AddErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddErrorHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddErrorHandler != nil && mm_atomic.LoadUint64(&m.afterAddErrorHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddErrorHandlerInspect logs each unmet expectation
func (m *OrderSenderMock) MinimockAddErrorHandlerInspect() {
	for _, e := range m.AddErrorHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderSenderMock.AddErrorHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddErrorHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddErrorHandlerCounter) < 1 {
		if m.AddErrorHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderSenderMock.AddErrorHandler")
		} else {
			m.t.Errorf("Expected call to OrderSenderMock.AddErrorHandler with params: %#v", *m.AddErrorHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddErrorHandler != nil && mm_atomic.LoadUint64(&m.afterAddErrorHandlerCounter) < 1 {
		m.t.Error("Expected call to OrderSenderMock.AddErrorHandler")
	}
}

type mOrderSenderMockAddSuccessHandler struct {
	mock               *OrderSenderMock
	defaultExpectation *OrderSenderMockAddSuccessHandlerExpectation
	expectations       []*OrderSenderMockAddSuccessHandlerExpectation

	callArgs []*OrderSenderMockAddSuccessHandlerParams
	mutex    sync.RWMutex
}

// OrderSenderMockAddSuccessHandlerExpectation specifies expectation struct of the OrderSender.AddSuccessHandler
type OrderSenderMockAddSuccessHandlerExpectation struct {
	mock   *OrderSenderMock
	params *OrderSenderMockAddSuccessHandlerParams

	Counter uint64
}

// OrderSenderMockAddSuccessHandlerParams contains parameters of the OrderSender.AddSuccessHandler
type OrderSenderMockAddSuccessHandlerParams struct {
	ctx       context.Context
	onSuccess func(orderID int64, status string)
}

// Expect sets up expected params for OrderSender.AddSuccessHandler
func (mmAddSuccessHandler *mOrderSenderMockAddSuccessHandler) Expect(ctx context.Context, onSuccess func(orderID int64, status string)) *mOrderSenderMockAddSuccessHandler {
	if mmAddSuccessHandler.mock.funcAddSuccessHandler != nil {
		mmAddSuccessHandler.mock.t.Fatalf("OrderSenderMock.AddSuccessHandler mock is already set by Set")
	}

	if mmAddSuccessHandler.defaultExpectation == nil {
		mmAddSuccessHandler.defaultExpectation = &OrderSenderMockAddSuccessHandlerExpectation{}
	}

	mmAddSuccessHandler.defaultExpectation.params = &OrderSenderMockAddSuccessHandlerParams{ctx, onSuccess}
	for _, e := range mmAddSuccessHandler.expectations {
		if minimock.Equal(e.params, mmAddSuccessHandler.defaultExpectation.params) {
			mmAddSuccessHandler.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSuccessHandler.defaultExpectation.params)
		}
	}

	return mmAddSuccessHandler
}

// Inspect accepts an inspector function that has same arguments as the OrderSender.AddSuccessHandler
func (mmAddSuccessHandler *mOrderSenderMockAddSuccessHandler) Inspect(f func(ctx context.Context, onSuccess func(orderID int64, status string))) *mOrderSenderMockAddSuccessHandler {
	if mmAddSuccessHandler.mock.inspectFuncAddSuccessHandler != nil {
		mmAddSuccessHandler.mock.t.Fatalf("Inspect function is already set for OrderSenderMock.AddSuccessHandler")
	}

	mmAddSuccessHandler.mock.inspectFuncAddSuccessHandler = f

	return mmAddSuccessHandler
}

// Return sets up results that will be returned by OrderSender.AddSuccessHandler
func (mmAddSuccessHandler *mOrderSenderMockAddSuccessHandler) Return() *OrderSenderMock {
	if mmAddSuccessHandler.mock.funcAddSuccessHandler != nil {
		mmAddSuccessHandler.mock.t.Fatalf("OrderSenderMock.AddSuccessHandler mock is already set by Set")
	}

	if mmAddSuccessHandler.defaultExpectation == nil {
		mmAddSuccessHandler.defaultExpectation = &OrderSenderMockAddSuccessHandlerExpectation{mock: mmAddSuccessHandler.mock}
	}

	return mmAddSuccessHandler.mock
}

// Set uses given function f to mock the OrderSender.AddSuccessHandler method
func (mmAddSuccessHandler *mOrderSenderMockAddSuccessHandler) Set(f func(ctx context.Context, onSuccess func(orderID int64, status string))) *OrderSenderMock {
	if mmAddSuccessHandler.defaultExpectation != nil {
		mmAddSuccessHandler.mock.t.Fatalf("Default expectation is already set for the OrderSender.AddSuccessHandler method")
	}

	if len(mmAddSuccessHandler.expectations) > 0 {
		mmAddSuccessHandler.mock.t.Fatalf("Some expectations are already set for the OrderSender.AddSuccessHandler method")
	}

	mmAddSuccessHandler.mock.funcAddSuccessHandler = f
	return mmAddSuccessHandler.mock
}

// AddSuccessHandler implements domain.OrderSender
func (mmAddSuccessHandler *OrderSenderMock) AddSuccessHandler(ctx context.Context, onSuccess func(orderID int64, status string)) {
	mm_atomic.AddUint64(&mmAddSuccessHandler.beforeAddSuccessHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSuccessHandler.afterAddSuccessHandlerCounter, 1)

	if mmAddSuccessHandler.inspectFuncAddSuccessHandler != nil {
		mmAddSuccessHandler.inspectFuncAddSuccessHandler(ctx, onSuccess)
	}

	mm_params := &OrderSenderMockAddSuccessHandlerParams{ctx, onSuccess}

	// Record call args
	mmAddSuccessHandler.AddSuccessHandlerMock.mutex.Lock()
	mmAddSuccessHandler.AddSuccessHandlerMock.callArgs = append(mmAddSuccessHandler.AddSuccessHandlerMock.callArgs, mm_params)
	mmAddSuccessHandler.AddSuccessHandlerMock.mutex.Unlock()

	for _, e := range mmAddSuccessHandler.AddSuccessHandlerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddSuccessHandler.AddSuccessHandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSuccessHandler.AddSuccessHandlerMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSuccessHandler.AddSuccessHandlerMock.defaultExpectation.params
		mm_got := OrderSenderMockAddSuccessHandlerParams{ctx, onSuccess}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSuccessHandler.t.Errorf("OrderSenderMock.AddSuccessHandler got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddSuccessHandler.funcAddSuccessHandler != nil {
		mmAddSuccessHandler.funcAddSuccessHandler(ctx, onSuccess)
		return
	}
	mmAddSuccessHandler.t.Fatalf("Unexpected call to OrderSenderMock.AddSuccessHandler. %v %v", ctx, onSuccess)

}

// AddSuccessHandlerAfterCounter returns a count of finished OrderSenderMock.AddSuccessHandler invocations
func (mmAddSuccessHandler *OrderSenderMock) AddSuccessHandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSuccessHandler.afterAddSuccessHandlerCounter)
}

// AddSuccessHandlerBeforeCounter returns a count of OrderSenderMock.AddSuccessHandler invocations
func (mmAddSuccessHandler *OrderSenderMock) AddSuccessHandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSuccessHandler.beforeAddSuccessHandlerCounter)
}

// Calls returns a list of arguments used in each call to OrderSenderMock.AddSuccessHandler.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSuccessHandler *mOrderSenderMockAddSuccessHandler) Calls() []*OrderSenderMockAddSuccessHandlerParams {
	mmAddSuccessHandler.mutex.RLock()

	argCopy := make([]*OrderSenderMockAddSuccessHandlerParams, len(mmAddSuccessHandler.callArgs))
	copy(argCopy, mmAddSuccessHandler.callArgs)

	mmAddSuccessHandler.mutex.RUnlock()

	return argCopy
}

// MinimockAddSuccessHandlerDone returns true if the count of the AddSuccessHandler invocations corresponds
// the number of defined expectations
func (m *OrderSenderMock) MinimockAddSuccessHandlerDone() bool {
	for _, e := range m.AddSuccessHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSuccessHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSuccessHandlerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSuccessHandler != nil && mm_atomic.LoadUint64(&m.afterAddSuccessHandlerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddSuccessHandlerInspect logs each unmet expectation
func (m *OrderSenderMock) MinimockAddSuccessHandlerInspect() {
	for _, e := range m.AddSuccessHandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderSenderMock.AddSuccessHandler with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddSuccessHandlerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddSuccessHandlerCounter) < 1 {
		if m.AddSuccessHandlerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderSenderMock.AddSuccessHandler")
		} else {
			m.t.Errorf("Expected call to OrderSenderMock.AddSuccessHandler with params: %#v", *m.AddSuccessHandlerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSuccessHandler != nil && mm_atomic.LoadUint64(&m.afterAddSuccessHandlerCounter) < 1 {
		m.t.Error("Expected call to OrderSenderMock.AddSuccessHandler")
	}
}

type mOrderSenderMockSendOrderStatus struct {
	mock               *OrderSenderMock
	defaultExpectation *OrderSenderMockSendOrderStatusExpectation
	expectations       []*OrderSenderMockSendOrderStatusExpectation

	callArgs []*OrderSenderMockSendOrderStatusParams
	mutex    sync.RWMutex
}

// OrderSenderMockSendOrderStatusExpectation specifies expectation struct of the OrderSender.SendOrderStatus
type OrderSenderMockSendOrderStatusExpectation struct {
	mock   *OrderSenderMock
	params *OrderSenderMockSendOrderStatusParams

	Counter uint64
}

// OrderSenderMockSendOrderStatusParams contains parameters of the OrderSender.SendOrderStatus
type OrderSenderMockSendOrderStatusParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// Expect sets up expected params for OrderSender.SendOrderStatus
func (mmSendOrderStatus *mOrderSenderMockSendOrderStatus) Expect(ctx context.Context, orderID int64, status string) *mOrderSenderMockSendOrderStatus {
	if mmSendOrderStatus.mock.funcSendOrderStatus != nil {
		mmSendOrderStatus.mock.t.Fatalf("OrderSenderMock.SendOrderStatus mock is already set by Set")
	}

	if mmSendOrderStatus.defaultExpectation == nil {
		mmSendOrderStatus.defaultExpectation = &OrderSenderMockSendOrderStatusExpectation{}
	}

	mmSendOrderStatus.defaultExpectation.params = &OrderSenderMockSendOrderStatusParams{ctx, orderID, status}
	for _, e := range mmSendOrderStatus.expectations {
		if minimock.Equal(e.params, mmSendOrderStatus.defaultExpectation.params) {
			mmSendOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendOrderStatus.defaultExpectation.params)
		}
	}

	return mmSendOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderSender.SendOrderStatus
func (mmSendOrderStatus *mOrderSenderMockSendOrderStatus) Inspect(f func(ctx context.Context, orderID int64, status string)) *mOrderSenderMockSendOrderStatus {
	if mmSendOrderStatus.mock.inspectFuncSendOrderStatus != nil {
		mmSendOrderStatus.mock.t.Fatalf("Inspect function is already set for OrderSenderMock.SendOrderStatus")
	}

	mmSendOrderStatus.mock.inspectFuncSendOrderStatus = f

	return mmSendOrderStatus
}

// Return sets up results that will be returned by OrderSender.SendOrderStatus
func (mmSendOrderStatus *mOrderSenderMockSendOrderStatus) Return() *OrderSenderMock {
	if mmSendOrderStatus.mock.funcSendOrderStatus != nil {
		mmSendOrderStatus.mock.t.Fatalf("OrderSenderMock.SendOrderStatus mock is already set by Set")
	}

	if mmSendOrderStatus.defaultExpectation == nil {
		mmSendOrderStatus.defaultExpectation = &OrderSenderMockSendOrderStatusExpectation{mock: mmSendOrderStatus.mock}
	}

	return mmSendOrderStatus.mock
}

// Set uses given function f to mock the OrderSender.SendOrderStatus method
func (mmSendOrderStatus *mOrderSenderMockSendOrderStatus) Set(f func(ctx context.Context, orderID int64, status string)) *OrderSenderMock {
	if mmSendOrderStatus.defaultExpectation != nil {
		mmSendOrderStatus.mock.t.Fatalf("Default expectation is already set for the OrderSender.SendOrderStatus method")
	}

	if len(mmSendOrderStatus.expectations) > 0 {
		mmSendOrderStatus.mock.t.Fatalf("Some expectations are already set for the OrderSender.SendOrderStatus method")
	}

	mmSendOrderStatus.mock.funcSendOrderStatus = f
	return mmSendOrderStatus.mock
}

// SendOrderStatus implements domain.OrderSender
func (mmSendOrderStatus *OrderSenderMock) SendOrderStatus(ctx context.Context, orderID int64, status string) {
	mm_atomic.AddUint64(&mmSendOrderStatus.beforeSendOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSendOrderStatus.afterSendOrderStatusCounter, 1)

	if mmSendOrderStatus.inspectFuncSendOrderStatus != nil {
		mmSendOrderStatus.inspectFuncSendOrderStatus(ctx, orderID, status)
	}

	mm_params := &OrderSenderMockSendOrderStatusParams{ctx, orderID, status}

	// Record call args
	mmSendOrderStatus.SendOrderStatusMock.mutex.Lock()
	mmSendOrderStatus.SendOrderStatusMock.callArgs = append(mmSendOrderStatus.SendOrderStatusMock.callArgs, mm_params)
	mmSendOrderStatus.SendOrderStatusMock.mutex.Unlock()

	for _, e := range mmSendOrderStatus.SendOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSendOrderStatus.SendOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendOrderStatus.SendOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSendOrderStatus.SendOrderStatusMock.defaultExpectation.params
		mm_got := OrderSenderMockSendOrderStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendOrderStatus.t.Errorf("OrderSenderMock.SendOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSendOrderStatus.funcSendOrderStatus != nil {
		mmSendOrderStatus.funcSendOrderStatus(ctx, orderID, status)
		return
	}
	mmSendOrderStatus.t.Fatalf("Unexpected call to OrderSenderMock.SendOrderStatus. %v %v %v", ctx, orderID, status)

}

// SendOrderStatusAfterCounter returns a count of finished OrderSenderMock.SendOrderStatus invocations
func (mmSendOrderStatus *OrderSenderMock) SendOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendOrderStatus.afterSendOrderStatusCounter)
}

// SendOrderStatusBeforeCounter returns a count of OrderSenderMock.SendOrderStatus invocations
func (mmSendOrderStatus *OrderSenderMock) SendOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendOrderStatus.beforeSendOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderSenderMock.SendOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendOrderStatus *mOrderSenderMockSendOrderStatus) Calls() []*OrderSenderMockSendOrderStatusParams {
	mmSendOrderStatus.mutex.RLock()

	argCopy := make([]*OrderSenderMockSendOrderStatusParams, len(mmSendOrderStatus.callArgs))
	copy(argCopy, mmSendOrderStatus.callArgs)

	mmSendOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSendOrderStatusDone returns true if the count of the SendOrderStatus invocations corresponds
// the number of defined expectations
func (m *OrderSenderMock) MinimockSendOrderStatusDone() bool {
	for _, e := range m.SendOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendOrderStatus != nil && mm_atomic.LoadUint64(&m.afterSendOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendOrderStatusInspect logs each unmet expectation
func (m *OrderSenderMock) MinimockSendOrderStatusInspect() {
	for _, e := range m.SendOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderSenderMock.SendOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendOrderStatusCounter) < 1 {
		if m.SendOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderSenderMock.SendOrderStatus")
		} else {
			m.t.Errorf("Expected call to OrderSenderMock.SendOrderStatus with params: %#v", *m.SendOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendOrderStatus != nil && mm_atomic.LoadUint64(&m.afterSendOrderStatusCounter) < 1 {
		m.t.Error("Expected call to OrderSenderMock.SendOrderStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderSenderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddErrorHandlerInspect()

		m.MinimockAddSuccessHandlerInspect()

		m.MinimockSendOrderStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderSenderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderSenderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddErrorHandlerDone() &&
		m.MinimockAddSuccessHandlerDone() &&
		m.MinimockSendOrderStatusDone()
}
