package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/domain.LOMSRepository -o ./mocks/loms_repository_minimock.go -n LOMSRepositoryMock

import (
	"context"
	mm_domain "route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LOMSRepositoryMock implements domain.LOMSRepository
type LOMSRepositoryMock struct {
	t minimock.Tester

	funcCancelReserve          func(ctx context.Context, orderID mm_domain.OrderID) (err error)
	inspectFuncCancelReserve   func(ctx context.Context, orderID mm_domain.OrderID)
	afterCancelReserveCounter  uint64
	beforeCancelReserveCounter uint64
	CancelReserveMock          mLOMSRepositoryMockCancelReserve

	funcChangeStatus          func(ctx context.Context, orderID mm_domain.OrderID, status string) (err error)
	inspectFuncChangeStatus   func(ctx context.Context, orderID mm_domain.OrderID, status string)
	afterChangeStatusCounter  uint64
	beforeChangeStatusCounter uint64
	ChangeStatusMock          mLOMSRepositoryMockChangeStatus

	funcCreateOrder          func(ctx context.Context, user int64, items []mm_domain.OrderItem) (o1 mm_domain.OrderID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, user int64, items []mm_domain.OrderItem)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mLOMSRepositoryMockCreateOrder

	funcCreateReserve          func(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem) (err error)
	inspectFuncCreateReserve   func(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem)
	afterCreateReserveCounter  uint64
	beforeCreateReserveCounter uint64
	CreateReserveMock          mLOMSRepositoryMockCreateReserve

	funcDeleteReserve          func(ctx context.Context, orderID mm_domain.OrderID) (err error)
	inspectFuncDeleteReserve   func(ctx context.Context, orderID mm_domain.OrderID)
	afterDeleteReserveCounter  uint64
	beforeDeleteReserveCounter uint64
	DeleteReserveMock          mLOMSRepositoryMockDeleteReserve

	funcGetOldOrders          func(ctx context.Context, createdBefore time.Time) (oa1 []mm_domain.OrderID, err error)
	inspectFuncGetOldOrders   func(ctx context.Context, createdBefore time.Time)
	afterGetOldOrdersCounter  uint64
	beforeGetOldOrdersCounter uint64
	GetOldOrdersMock          mLOMSRepositoryMockGetOldOrders

	funcGetStatus          func(ctx context.Context, orderID mm_domain.OrderID) (s1 string, err error)
	inspectFuncGetStatus   func(ctx context.Context, orderID mm_domain.OrderID)
	afterGetStatusCounter  uint64
	beforeGetStatusCounter uint64
	GetStatusMock          mLOMSRepositoryMockGetStatus

	funcListOrder          func(ctx context.Context, orderID mm_domain.OrderID) (o1 mm_domain.Order, err error)
	inspectFuncListOrder   func(ctx context.Context, orderID mm_domain.OrderID)
	afterListOrderCounter  uint64
	beforeListOrderCounter uint64
	ListOrderMock          mLOMSRepositoryMockListOrder

	funcStocks          func(ctx context.Context, sku uint32) (sa1 []mm_domain.Stock, err error)
	inspectFuncStocks   func(ctx context.Context, sku uint32)
	afterStocksCounter  uint64
	beforeStocksCounter uint64
	StocksMock          mLOMSRepositoryMockStocks
}

// NewLOMSRepositoryMock returns a mock for domain.LOMSRepository
func NewLOMSRepositoryMock(t minimock.Tester) *LOMSRepositoryMock {
	m := &LOMSRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelReserveMock = mLOMSRepositoryMockCancelReserve{mock: m}
	m.CancelReserveMock.callArgs = []*LOMSRepositoryMockCancelReserveParams{}

	m.ChangeStatusMock = mLOMSRepositoryMockChangeStatus{mock: m}
	m.ChangeStatusMock.callArgs = []*LOMSRepositoryMockChangeStatusParams{}

	m.CreateOrderMock = mLOMSRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*LOMSRepositoryMockCreateOrderParams{}

	m.CreateReserveMock = mLOMSRepositoryMockCreateReserve{mock: m}
	m.CreateReserveMock.callArgs = []*LOMSRepositoryMockCreateReserveParams{}

	m.DeleteReserveMock = mLOMSRepositoryMockDeleteReserve{mock: m}
	m.DeleteReserveMock.callArgs = []*LOMSRepositoryMockDeleteReserveParams{}

	m.GetOldOrdersMock = mLOMSRepositoryMockGetOldOrders{mock: m}
	m.GetOldOrdersMock.callArgs = []*LOMSRepositoryMockGetOldOrdersParams{}

	m.GetStatusMock = mLOMSRepositoryMockGetStatus{mock: m}
	m.GetStatusMock.callArgs = []*LOMSRepositoryMockGetStatusParams{}

	m.ListOrderMock = mLOMSRepositoryMockListOrder{mock: m}
	m.ListOrderMock.callArgs = []*LOMSRepositoryMockListOrderParams{}

	m.StocksMock = mLOMSRepositoryMockStocks{mock: m}
	m.StocksMock.callArgs = []*LOMSRepositoryMockStocksParams{}

	return m
}

type mLOMSRepositoryMockCancelReserve struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockCancelReserveExpectation
	expectations       []*LOMSRepositoryMockCancelReserveExpectation

	callArgs []*LOMSRepositoryMockCancelReserveParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockCancelReserveExpectation specifies expectation struct of the LOMSRepository.CancelReserve
type LOMSRepositoryMockCancelReserveExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockCancelReserveParams
	results *LOMSRepositoryMockCancelReserveResults
	Counter uint64
}

// LOMSRepositoryMockCancelReserveParams contains parameters of the LOMSRepository.CancelReserve
type LOMSRepositoryMockCancelReserveParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
}

// LOMSRepositoryMockCancelReserveResults contains results of the LOMSRepository.CancelReserve
type LOMSRepositoryMockCancelReserveResults struct {
	err error
}

// Expect sets up expected params for LOMSRepository.CancelReserve
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) Expect(ctx context.Context, orderID mm_domain.OrderID) *mLOMSRepositoryMockCancelReserve {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("LOMSRepositoryMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &LOMSRepositoryMockCancelReserveExpectation{}
	}

	mmCancelReserve.defaultExpectation.params = &LOMSRepositoryMockCancelReserveParams{ctx, orderID}
	for _, e := range mmCancelReserve.expectations {
		if minimock.Equal(e.params, mmCancelReserve.defaultExpectation.params) {
			mmCancelReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReserve.defaultExpectation.params)
		}
	}

	return mmCancelReserve
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.CancelReserve
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID)) *mLOMSRepositoryMockCancelReserve {
	if mmCancelReserve.mock.inspectFuncCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.CancelReserve")
	}

	mmCancelReserve.mock.inspectFuncCancelReserve = f

	return mmCancelReserve
}

// Return sets up results that will be returned by LOMSRepository.CancelReserve
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) Return(err error) *LOMSRepositoryMock {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("LOMSRepositoryMock.CancelReserve mock is already set by Set")
	}

	if mmCancelReserve.defaultExpectation == nil {
		mmCancelReserve.defaultExpectation = &LOMSRepositoryMockCancelReserveExpectation{mock: mmCancelReserve.mock}
	}
	mmCancelReserve.defaultExpectation.results = &LOMSRepositoryMockCancelReserveResults{err}
	return mmCancelReserve.mock
}

// Set uses given function f to mock the LOMSRepository.CancelReserve method
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) Set(f func(ctx context.Context, orderID mm_domain.OrderID) (err error)) *LOMSRepositoryMock {
	if mmCancelReserve.defaultExpectation != nil {
		mmCancelReserve.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.CancelReserve method")
	}

	if len(mmCancelReserve.expectations) > 0 {
		mmCancelReserve.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.CancelReserve method")
	}

	mmCancelReserve.mock.funcCancelReserve = f
	return mmCancelReserve.mock
}

// When sets expectation for the LOMSRepository.CancelReserve which will trigger the result defined by the following
// Then helper
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) When(ctx context.Context, orderID mm_domain.OrderID) *LOMSRepositoryMockCancelReserveExpectation {
	if mmCancelReserve.mock.funcCancelReserve != nil {
		mmCancelReserve.mock.t.Fatalf("LOMSRepositoryMock.CancelReserve mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockCancelReserveExpectation{
		mock:   mmCancelReserve.mock,
		params: &LOMSRepositoryMockCancelReserveParams{ctx, orderID},
	}
	mmCancelReserve.expectations = append(mmCancelReserve.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.CancelReserve return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockCancelReserveExpectation) Then(err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockCancelReserveResults{err}
	return e.mock
}

// CancelReserve implements domain.LOMSRepository
func (mmCancelReserve *LOMSRepositoryMock) CancelReserve(ctx context.Context, orderID mm_domain.OrderID) (err error) {
	mm_atomic.AddUint64(&mmCancelReserve.beforeCancelReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReserve.afterCancelReserveCounter, 1)

	if mmCancelReserve.inspectFuncCancelReserve != nil {
		mmCancelReserve.inspectFuncCancelReserve(ctx, orderID)
	}

	mm_params := &LOMSRepositoryMockCancelReserveParams{ctx, orderID}

	// Record call args
	mmCancelReserve.CancelReserveMock.mutex.Lock()
	mmCancelReserve.CancelReserveMock.callArgs = append(mmCancelReserve.CancelReserveMock.callArgs, mm_params)
	mmCancelReserve.CancelReserveMock.mutex.Unlock()

	for _, e := range mmCancelReserve.CancelReserveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReserve.CancelReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReserve.CancelReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReserve.CancelReserveMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockCancelReserveParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReserve.t.Errorf("LOMSRepositoryMock.CancelReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReserve.CancelReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReserve.t.Fatal("No results are set for the LOMSRepositoryMock.CancelReserve")
		}
		return (*mm_results).err
	}
	if mmCancelReserve.funcCancelReserve != nil {
		return mmCancelReserve.funcCancelReserve(ctx, orderID)
	}
	mmCancelReserve.t.Fatalf("Unexpected call to LOMSRepositoryMock.CancelReserve. %v %v", ctx, orderID)
	return
}

// CancelReserveAfterCounter returns a count of finished LOMSRepositoryMock.CancelReserve invocations
func (mmCancelReserve *LOMSRepositoryMock) CancelReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserve.afterCancelReserveCounter)
}

// CancelReserveBeforeCounter returns a count of LOMSRepositoryMock.CancelReserve invocations
func (mmCancelReserve *LOMSRepositoryMock) CancelReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReserve.beforeCancelReserveCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.CancelReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReserve *mLOMSRepositoryMockCancelReserve) Calls() []*LOMSRepositoryMockCancelReserveParams {
	mmCancelReserve.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockCancelReserveParams, len(mmCancelReserve.callArgs))
	copy(argCopy, mmCancelReserve.callArgs)

	mmCancelReserve.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReserveDone returns true if the count of the CancelReserve invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockCancelReserveDone() bool {
	for _, e := range m.CancelReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReserve != nil && mm_atomic.LoadUint64(&m.afterCancelReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelReserveInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockCancelReserveInspect() {
	for _, e := range m.CancelReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CancelReserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelReserveCounter) < 1 {
		if m.CancelReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.CancelReserve")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CancelReserve with params: %#v", *m.CancelReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReserve != nil && mm_atomic.LoadUint64(&m.afterCancelReserveCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.CancelReserve")
	}
}

type mLOMSRepositoryMockChangeStatus struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockChangeStatusExpectation
	expectations       []*LOMSRepositoryMockChangeStatusExpectation

	callArgs []*LOMSRepositoryMockChangeStatusParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockChangeStatusExpectation specifies expectation struct of the LOMSRepository.ChangeStatus
type LOMSRepositoryMockChangeStatusExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockChangeStatusParams
	results *LOMSRepositoryMockChangeStatusResults
	Counter uint64
}

// LOMSRepositoryMockChangeStatusParams contains parameters of the LOMSRepository.ChangeStatus
type LOMSRepositoryMockChangeStatusParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
	status  string
}

// LOMSRepositoryMockChangeStatusResults contains results of the LOMSRepository.ChangeStatus
type LOMSRepositoryMockChangeStatusResults struct {
	err error
}

// Expect sets up expected params for LOMSRepository.ChangeStatus
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) Expect(ctx context.Context, orderID mm_domain.OrderID, status string) *mLOMSRepositoryMockChangeStatus {
	if mmChangeStatus.mock.funcChangeStatus != nil {
		mmChangeStatus.mock.t.Fatalf("LOMSRepositoryMock.ChangeStatus mock is already set by Set")
	}

	if mmChangeStatus.defaultExpectation == nil {
		mmChangeStatus.defaultExpectation = &LOMSRepositoryMockChangeStatusExpectation{}
	}

	mmChangeStatus.defaultExpectation.params = &LOMSRepositoryMockChangeStatusParams{ctx, orderID, status}
	for _, e := range mmChangeStatus.expectations {
		if minimock.Equal(e.params, mmChangeStatus.defaultExpectation.params) {
			mmChangeStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeStatus.defaultExpectation.params)
		}
	}

	return mmChangeStatus
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.ChangeStatus
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID, status string)) *mLOMSRepositoryMockChangeStatus {
	if mmChangeStatus.mock.inspectFuncChangeStatus != nil {
		mmChangeStatus.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.ChangeStatus")
	}

	mmChangeStatus.mock.inspectFuncChangeStatus = f

	return mmChangeStatus
}

// Return sets up results that will be returned by LOMSRepository.ChangeStatus
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) Return(err error) *LOMSRepositoryMock {
	if mmChangeStatus.mock.funcChangeStatus != nil {
		mmChangeStatus.mock.t.Fatalf("LOMSRepositoryMock.ChangeStatus mock is already set by Set")
	}

	if mmChangeStatus.defaultExpectation == nil {
		mmChangeStatus.defaultExpectation = &LOMSRepositoryMockChangeStatusExpectation{mock: mmChangeStatus.mock}
	}
	mmChangeStatus.defaultExpectation.results = &LOMSRepositoryMockChangeStatusResults{err}
	return mmChangeStatus.mock
}

// Set uses given function f to mock the LOMSRepository.ChangeStatus method
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) Set(f func(ctx context.Context, orderID mm_domain.OrderID, status string) (err error)) *LOMSRepositoryMock {
	if mmChangeStatus.defaultExpectation != nil {
		mmChangeStatus.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.ChangeStatus method")
	}

	if len(mmChangeStatus.expectations) > 0 {
		mmChangeStatus.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.ChangeStatus method")
	}

	mmChangeStatus.mock.funcChangeStatus = f
	return mmChangeStatus.mock
}

// When sets expectation for the LOMSRepository.ChangeStatus which will trigger the result defined by the following
// Then helper
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) When(ctx context.Context, orderID mm_domain.OrderID, status string) *LOMSRepositoryMockChangeStatusExpectation {
	if mmChangeStatus.mock.funcChangeStatus != nil {
		mmChangeStatus.mock.t.Fatalf("LOMSRepositoryMock.ChangeStatus mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockChangeStatusExpectation{
		mock:   mmChangeStatus.mock,
		params: &LOMSRepositoryMockChangeStatusParams{ctx, orderID, status},
	}
	mmChangeStatus.expectations = append(mmChangeStatus.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.ChangeStatus return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockChangeStatusExpectation) Then(err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockChangeStatusResults{err}
	return e.mock
}

// ChangeStatus implements domain.LOMSRepository
func (mmChangeStatus *LOMSRepositoryMock) ChangeStatus(ctx context.Context, orderID mm_domain.OrderID, status string) (err error) {
	mm_atomic.AddUint64(&mmChangeStatus.beforeChangeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeStatus.afterChangeStatusCounter, 1)

	if mmChangeStatus.inspectFuncChangeStatus != nil {
		mmChangeStatus.inspectFuncChangeStatus(ctx, orderID, status)
	}

	mm_params := &LOMSRepositoryMockChangeStatusParams{ctx, orderID, status}

	// Record call args
	mmChangeStatus.ChangeStatusMock.mutex.Lock()
	mmChangeStatus.ChangeStatusMock.callArgs = append(mmChangeStatus.ChangeStatusMock.callArgs, mm_params)
	mmChangeStatus.ChangeStatusMock.mutex.Unlock()

	for _, e := range mmChangeStatus.ChangeStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangeStatus.ChangeStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeStatus.ChangeStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeStatus.ChangeStatusMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockChangeStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeStatus.t.Errorf("LOMSRepositoryMock.ChangeStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeStatus.ChangeStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeStatus.t.Fatal("No results are set for the LOMSRepositoryMock.ChangeStatus")
		}
		return (*mm_results).err
	}
	if mmChangeStatus.funcChangeStatus != nil {
		return mmChangeStatus.funcChangeStatus(ctx, orderID, status)
	}
	mmChangeStatus.t.Fatalf("Unexpected call to LOMSRepositoryMock.ChangeStatus. %v %v %v", ctx, orderID, status)
	return
}

// ChangeStatusAfterCounter returns a count of finished LOMSRepositoryMock.ChangeStatus invocations
func (mmChangeStatus *LOMSRepositoryMock) ChangeStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeStatus.afterChangeStatusCounter)
}

// ChangeStatusBeforeCounter returns a count of LOMSRepositoryMock.ChangeStatus invocations
func (mmChangeStatus *LOMSRepositoryMock) ChangeStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeStatus.beforeChangeStatusCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.ChangeStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeStatus *mLOMSRepositoryMockChangeStatus) Calls() []*LOMSRepositoryMockChangeStatusParams {
	mmChangeStatus.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockChangeStatusParams, len(mmChangeStatus.callArgs))
	copy(argCopy, mmChangeStatus.callArgs)

	mmChangeStatus.mutex.RUnlock()

	return argCopy
}

// MinimockChangeStatusDone returns true if the count of the ChangeStatus invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockChangeStatusDone() bool {
	for _, e := range m.ChangeStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeStatus != nil && mm_atomic.LoadUint64(&m.afterChangeStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockChangeStatusInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockChangeStatusInspect() {
	for _, e := range m.ChangeStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.ChangeStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeStatusCounter) < 1 {
		if m.ChangeStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.ChangeStatus")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.ChangeStatus with params: %#v", *m.ChangeStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeStatus != nil && mm_atomic.LoadUint64(&m.afterChangeStatusCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.ChangeStatus")
	}
}

type mLOMSRepositoryMockCreateOrder struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockCreateOrderExpectation
	expectations       []*LOMSRepositoryMockCreateOrderExpectation

	callArgs []*LOMSRepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockCreateOrderExpectation specifies expectation struct of the LOMSRepository.CreateOrder
type LOMSRepositoryMockCreateOrderExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockCreateOrderParams
	results *LOMSRepositoryMockCreateOrderResults
	Counter uint64
}

// LOMSRepositoryMockCreateOrderParams contains parameters of the LOMSRepository.CreateOrder
type LOMSRepositoryMockCreateOrderParams struct {
	ctx   context.Context
	user  int64
	items []mm_domain.OrderItem
}

// LOMSRepositoryMockCreateOrderResults contains results of the LOMSRepository.CreateOrder
type LOMSRepositoryMockCreateOrderResults struct {
	o1  mm_domain.OrderID
	err error
}

// Expect sets up expected params for LOMSRepository.CreateOrder
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) Expect(ctx context.Context, user int64, items []mm_domain.OrderItem) *mLOMSRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LOMSRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LOMSRepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &LOMSRepositoryMockCreateOrderParams{ctx, user, items}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.CreateOrder
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, user int64, items []mm_domain.OrderItem)) *mLOMSRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by LOMSRepository.CreateOrder
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) Return(o1 mm_domain.OrderID, err error) *LOMSRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LOMSRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LOMSRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &LOMSRepositoryMockCreateOrderResults{o1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the LOMSRepository.CreateOrder method
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) Set(f func(ctx context.Context, user int64, items []mm_domain.OrderItem) (o1 mm_domain.OrderID, err error)) *LOMSRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the LOMSRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) When(ctx context.Context, user int64, items []mm_domain.OrderItem) *LOMSRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LOMSRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &LOMSRepositoryMockCreateOrderParams{ctx, user, items},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockCreateOrderExpectation) Then(o1 mm_domain.OrderID, err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockCreateOrderResults{o1, err}
	return e.mock
}

// CreateOrder implements domain.LOMSRepository
func (mmCreateOrder *LOMSRepositoryMock) CreateOrder(ctx context.Context, user int64, items []mm_domain.OrderItem) (o1 mm_domain.OrderID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, user, items)
	}

	mm_params := &LOMSRepositoryMockCreateOrderParams{ctx, user, items}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockCreateOrderParams{ctx, user, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("LOMSRepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the LOMSRepositoryMock.CreateOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, user, items)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to LOMSRepositoryMock.CreateOrder. %v %v %v", ctx, user, items)
	return
}

// CreateOrderAfterCounter returns a count of finished LOMSRepositoryMock.CreateOrder invocations
func (mmCreateOrder *LOMSRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of LOMSRepositoryMock.CreateOrder invocations
func (mmCreateOrder *LOMSRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mLOMSRepositoryMockCreateOrder) Calls() []*LOMSRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.CreateOrder")
	}
}

type mLOMSRepositoryMockCreateReserve struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockCreateReserveExpectation
	expectations       []*LOMSRepositoryMockCreateReserveExpectation

	callArgs []*LOMSRepositoryMockCreateReserveParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockCreateReserveExpectation specifies expectation struct of the LOMSRepository.CreateReserve
type LOMSRepositoryMockCreateReserveExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockCreateReserveParams
	results *LOMSRepositoryMockCreateReserveResults
	Counter uint64
}

// LOMSRepositoryMockCreateReserveParams contains parameters of the LOMSRepository.CreateReserve
type LOMSRepositoryMockCreateReserveParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
	items   []mm_domain.OrderItem
}

// LOMSRepositoryMockCreateReserveResults contains results of the LOMSRepository.CreateReserve
type LOMSRepositoryMockCreateReserveResults struct {
	err error
}

// Expect sets up expected params for LOMSRepository.CreateReserve
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) Expect(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem) *mLOMSRepositoryMockCreateReserve {
	if mmCreateReserve.mock.funcCreateReserve != nil {
		mmCreateReserve.mock.t.Fatalf("LOMSRepositoryMock.CreateReserve mock is already set by Set")
	}

	if mmCreateReserve.defaultExpectation == nil {
		mmCreateReserve.defaultExpectation = &LOMSRepositoryMockCreateReserveExpectation{}
	}

	mmCreateReserve.defaultExpectation.params = &LOMSRepositoryMockCreateReserveParams{ctx, orderID, items}
	for _, e := range mmCreateReserve.expectations {
		if minimock.Equal(e.params, mmCreateReserve.defaultExpectation.params) {
			mmCreateReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReserve.defaultExpectation.params)
		}
	}

	return mmCreateReserve
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.CreateReserve
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem)) *mLOMSRepositoryMockCreateReserve {
	if mmCreateReserve.mock.inspectFuncCreateReserve != nil {
		mmCreateReserve.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.CreateReserve")
	}

	mmCreateReserve.mock.inspectFuncCreateReserve = f

	return mmCreateReserve
}

// Return sets up results that will be returned by LOMSRepository.CreateReserve
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) Return(err error) *LOMSRepositoryMock {
	if mmCreateReserve.mock.funcCreateReserve != nil {
		mmCreateReserve.mock.t.Fatalf("LOMSRepositoryMock.CreateReserve mock is already set by Set")
	}

	if mmCreateReserve.defaultExpectation == nil {
		mmCreateReserve.defaultExpectation = &LOMSRepositoryMockCreateReserveExpectation{mock: mmCreateReserve.mock}
	}
	mmCreateReserve.defaultExpectation.results = &LOMSRepositoryMockCreateReserveResults{err}
	return mmCreateReserve.mock
}

// Set uses given function f to mock the LOMSRepository.CreateReserve method
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) Set(f func(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem) (err error)) *LOMSRepositoryMock {
	if mmCreateReserve.defaultExpectation != nil {
		mmCreateReserve.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.CreateReserve method")
	}

	if len(mmCreateReserve.expectations) > 0 {
		mmCreateReserve.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.CreateReserve method")
	}

	mmCreateReserve.mock.funcCreateReserve = f
	return mmCreateReserve.mock
}

// When sets expectation for the LOMSRepository.CreateReserve which will trigger the result defined by the following
// Then helper
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) When(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem) *LOMSRepositoryMockCreateReserveExpectation {
	if mmCreateReserve.mock.funcCreateReserve != nil {
		mmCreateReserve.mock.t.Fatalf("LOMSRepositoryMock.CreateReserve mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockCreateReserveExpectation{
		mock:   mmCreateReserve.mock,
		params: &LOMSRepositoryMockCreateReserveParams{ctx, orderID, items},
	}
	mmCreateReserve.expectations = append(mmCreateReserve.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.CreateReserve return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockCreateReserveExpectation) Then(err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockCreateReserveResults{err}
	return e.mock
}

// CreateReserve implements domain.LOMSRepository
func (mmCreateReserve *LOMSRepositoryMock) CreateReserve(ctx context.Context, orderID mm_domain.OrderID, items []mm_domain.OrderItem) (err error) {
	mm_atomic.AddUint64(&mmCreateReserve.beforeCreateReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReserve.afterCreateReserveCounter, 1)

	if mmCreateReserve.inspectFuncCreateReserve != nil {
		mmCreateReserve.inspectFuncCreateReserve(ctx, orderID, items)
	}

	mm_params := &LOMSRepositoryMockCreateReserveParams{ctx, orderID, items}

	// Record call args
	mmCreateReserve.CreateReserveMock.mutex.Lock()
	mmCreateReserve.CreateReserveMock.callArgs = append(mmCreateReserve.CreateReserveMock.callArgs, mm_params)
	mmCreateReserve.CreateReserveMock.mutex.Unlock()

	for _, e := range mmCreateReserve.CreateReserveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateReserve.CreateReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReserve.CreateReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReserve.CreateReserveMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockCreateReserveParams{ctx, orderID, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReserve.t.Errorf("LOMSRepositoryMock.CreateReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReserve.CreateReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReserve.t.Fatal("No results are set for the LOMSRepositoryMock.CreateReserve")
		}
		return (*mm_results).err
	}
	if mmCreateReserve.funcCreateReserve != nil {
		return mmCreateReserve.funcCreateReserve(ctx, orderID, items)
	}
	mmCreateReserve.t.Fatalf("Unexpected call to LOMSRepositoryMock.CreateReserve. %v %v %v", ctx, orderID, items)
	return
}

// CreateReserveAfterCounter returns a count of finished LOMSRepositoryMock.CreateReserve invocations
func (mmCreateReserve *LOMSRepositoryMock) CreateReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReserve.afterCreateReserveCounter)
}

// CreateReserveBeforeCounter returns a count of LOMSRepositoryMock.CreateReserve invocations
func (mmCreateReserve *LOMSRepositoryMock) CreateReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReserve.beforeCreateReserveCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.CreateReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReserve *mLOMSRepositoryMockCreateReserve) Calls() []*LOMSRepositoryMockCreateReserveParams {
	mmCreateReserve.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockCreateReserveParams, len(mmCreateReserve.callArgs))
	copy(argCopy, mmCreateReserve.callArgs)

	mmCreateReserve.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReserveDone returns true if the count of the CreateReserve invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockCreateReserveDone() bool {
	for _, e := range m.CreateReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReserve != nil && mm_atomic.LoadUint64(&m.afterCreateReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateReserveInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockCreateReserveInspect() {
	for _, e := range m.CreateReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CreateReserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReserveCounter) < 1 {
		if m.CreateReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.CreateReserve")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.CreateReserve with params: %#v", *m.CreateReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReserve != nil && mm_atomic.LoadUint64(&m.afterCreateReserveCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.CreateReserve")
	}
}

type mLOMSRepositoryMockDeleteReserve struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockDeleteReserveExpectation
	expectations       []*LOMSRepositoryMockDeleteReserveExpectation

	callArgs []*LOMSRepositoryMockDeleteReserveParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockDeleteReserveExpectation specifies expectation struct of the LOMSRepository.DeleteReserve
type LOMSRepositoryMockDeleteReserveExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockDeleteReserveParams
	results *LOMSRepositoryMockDeleteReserveResults
	Counter uint64
}

// LOMSRepositoryMockDeleteReserveParams contains parameters of the LOMSRepository.DeleteReserve
type LOMSRepositoryMockDeleteReserveParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
}

// LOMSRepositoryMockDeleteReserveResults contains results of the LOMSRepository.DeleteReserve
type LOMSRepositoryMockDeleteReserveResults struct {
	err error
}

// Expect sets up expected params for LOMSRepository.DeleteReserve
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) Expect(ctx context.Context, orderID mm_domain.OrderID) *mLOMSRepositoryMockDeleteReserve {
	if mmDeleteReserve.mock.funcDeleteReserve != nil {
		mmDeleteReserve.mock.t.Fatalf("LOMSRepositoryMock.DeleteReserve mock is already set by Set")
	}

	if mmDeleteReserve.defaultExpectation == nil {
		mmDeleteReserve.defaultExpectation = &LOMSRepositoryMockDeleteReserveExpectation{}
	}

	mmDeleteReserve.defaultExpectation.params = &LOMSRepositoryMockDeleteReserveParams{ctx, orderID}
	for _, e := range mmDeleteReserve.expectations {
		if minimock.Equal(e.params, mmDeleteReserve.defaultExpectation.params) {
			mmDeleteReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReserve.defaultExpectation.params)
		}
	}

	return mmDeleteReserve
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.DeleteReserve
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID)) *mLOMSRepositoryMockDeleteReserve {
	if mmDeleteReserve.mock.inspectFuncDeleteReserve != nil {
		mmDeleteReserve.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.DeleteReserve")
	}

	mmDeleteReserve.mock.inspectFuncDeleteReserve = f

	return mmDeleteReserve
}

// Return sets up results that will be returned by LOMSRepository.DeleteReserve
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) Return(err error) *LOMSRepositoryMock {
	if mmDeleteReserve.mock.funcDeleteReserve != nil {
		mmDeleteReserve.mock.t.Fatalf("LOMSRepositoryMock.DeleteReserve mock is already set by Set")
	}

	if mmDeleteReserve.defaultExpectation == nil {
		mmDeleteReserve.defaultExpectation = &LOMSRepositoryMockDeleteReserveExpectation{mock: mmDeleteReserve.mock}
	}
	mmDeleteReserve.defaultExpectation.results = &LOMSRepositoryMockDeleteReserveResults{err}
	return mmDeleteReserve.mock
}

// Set uses given function f to mock the LOMSRepository.DeleteReserve method
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) Set(f func(ctx context.Context, orderID mm_domain.OrderID) (err error)) *LOMSRepositoryMock {
	if mmDeleteReserve.defaultExpectation != nil {
		mmDeleteReserve.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.DeleteReserve method")
	}

	if len(mmDeleteReserve.expectations) > 0 {
		mmDeleteReserve.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.DeleteReserve method")
	}

	mmDeleteReserve.mock.funcDeleteReserve = f
	return mmDeleteReserve.mock
}

// When sets expectation for the LOMSRepository.DeleteReserve which will trigger the result defined by the following
// Then helper
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) When(ctx context.Context, orderID mm_domain.OrderID) *LOMSRepositoryMockDeleteReserveExpectation {
	if mmDeleteReserve.mock.funcDeleteReserve != nil {
		mmDeleteReserve.mock.t.Fatalf("LOMSRepositoryMock.DeleteReserve mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockDeleteReserveExpectation{
		mock:   mmDeleteReserve.mock,
		params: &LOMSRepositoryMockDeleteReserveParams{ctx, orderID},
	}
	mmDeleteReserve.expectations = append(mmDeleteReserve.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.DeleteReserve return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockDeleteReserveExpectation) Then(err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockDeleteReserveResults{err}
	return e.mock
}

// DeleteReserve implements domain.LOMSRepository
func (mmDeleteReserve *LOMSRepositoryMock) DeleteReserve(ctx context.Context, orderID mm_domain.OrderID) (err error) {
	mm_atomic.AddUint64(&mmDeleteReserve.beforeDeleteReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReserve.afterDeleteReserveCounter, 1)

	if mmDeleteReserve.inspectFuncDeleteReserve != nil {
		mmDeleteReserve.inspectFuncDeleteReserve(ctx, orderID)
	}

	mm_params := &LOMSRepositoryMockDeleteReserveParams{ctx, orderID}

	// Record call args
	mmDeleteReserve.DeleteReserveMock.mutex.Lock()
	mmDeleteReserve.DeleteReserveMock.callArgs = append(mmDeleteReserve.DeleteReserveMock.callArgs, mm_params)
	mmDeleteReserve.DeleteReserveMock.mutex.Unlock()

	for _, e := range mmDeleteReserve.DeleteReserveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteReserve.DeleteReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReserve.DeleteReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReserve.DeleteReserveMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockDeleteReserveParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReserve.t.Errorf("LOMSRepositoryMock.DeleteReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteReserve.DeleteReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteReserve.t.Fatal("No results are set for the LOMSRepositoryMock.DeleteReserve")
		}
		return (*mm_results).err
	}
	if mmDeleteReserve.funcDeleteReserve != nil {
		return mmDeleteReserve.funcDeleteReserve(ctx, orderID)
	}
	mmDeleteReserve.t.Fatalf("Unexpected call to LOMSRepositoryMock.DeleteReserve. %v %v", ctx, orderID)
	return
}

// DeleteReserveAfterCounter returns a count of finished LOMSRepositoryMock.DeleteReserve invocations
func (mmDeleteReserve *LOMSRepositoryMock) DeleteReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReserve.afterDeleteReserveCounter)
}

// DeleteReserveBeforeCounter returns a count of LOMSRepositoryMock.DeleteReserve invocations
func (mmDeleteReserve *LOMSRepositoryMock) DeleteReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReserve.beforeDeleteReserveCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.DeleteReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReserve *mLOMSRepositoryMockDeleteReserve) Calls() []*LOMSRepositoryMockDeleteReserveParams {
	mmDeleteReserve.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockDeleteReserveParams, len(mmDeleteReserve.callArgs))
	copy(argCopy, mmDeleteReserve.callArgs)

	mmDeleteReserve.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReserveDone returns true if the count of the DeleteReserve invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockDeleteReserveDone() bool {
	for _, e := range m.DeleteReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReserve != nil && mm_atomic.LoadUint64(&m.afterDeleteReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteReserveInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockDeleteReserveInspect() {
	for _, e := range m.DeleteReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.DeleteReserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteReserveCounter) < 1 {
		if m.DeleteReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.DeleteReserve")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.DeleteReserve with params: %#v", *m.DeleteReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReserve != nil && mm_atomic.LoadUint64(&m.afterDeleteReserveCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.DeleteReserve")
	}
}

type mLOMSRepositoryMockGetOldOrders struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockGetOldOrdersExpectation
	expectations       []*LOMSRepositoryMockGetOldOrdersExpectation

	callArgs []*LOMSRepositoryMockGetOldOrdersParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockGetOldOrdersExpectation specifies expectation struct of the LOMSRepository.GetOldOrders
type LOMSRepositoryMockGetOldOrdersExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockGetOldOrdersParams
	results *LOMSRepositoryMockGetOldOrdersResults
	Counter uint64
}

// LOMSRepositoryMockGetOldOrdersParams contains parameters of the LOMSRepository.GetOldOrders
type LOMSRepositoryMockGetOldOrdersParams struct {
	ctx           context.Context
	createdBefore time.Time
}

// LOMSRepositoryMockGetOldOrdersResults contains results of the LOMSRepository.GetOldOrders
type LOMSRepositoryMockGetOldOrdersResults struct {
	oa1 []mm_domain.OrderID
	err error
}

// Expect sets up expected params for LOMSRepository.GetOldOrders
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) Expect(ctx context.Context, createdBefore time.Time) *mLOMSRepositoryMockGetOldOrders {
	if mmGetOldOrders.mock.funcGetOldOrders != nil {
		mmGetOldOrders.mock.t.Fatalf("LOMSRepositoryMock.GetOldOrders mock is already set by Set")
	}

	if mmGetOldOrders.defaultExpectation == nil {
		mmGetOldOrders.defaultExpectation = &LOMSRepositoryMockGetOldOrdersExpectation{}
	}

	mmGetOldOrders.defaultExpectation.params = &LOMSRepositoryMockGetOldOrdersParams{ctx, createdBefore}
	for _, e := range mmGetOldOrders.expectations {
		if minimock.Equal(e.params, mmGetOldOrders.defaultExpectation.params) {
			mmGetOldOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOldOrders.defaultExpectation.params)
		}
	}

	return mmGetOldOrders
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.GetOldOrders
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) Inspect(f func(ctx context.Context, createdBefore time.Time)) *mLOMSRepositoryMockGetOldOrders {
	if mmGetOldOrders.mock.inspectFuncGetOldOrders != nil {
		mmGetOldOrders.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.GetOldOrders")
	}

	mmGetOldOrders.mock.inspectFuncGetOldOrders = f

	return mmGetOldOrders
}

// Return sets up results that will be returned by LOMSRepository.GetOldOrders
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) Return(oa1 []mm_domain.OrderID, err error) *LOMSRepositoryMock {
	if mmGetOldOrders.mock.funcGetOldOrders != nil {
		mmGetOldOrders.mock.t.Fatalf("LOMSRepositoryMock.GetOldOrders mock is already set by Set")
	}

	if mmGetOldOrders.defaultExpectation == nil {
		mmGetOldOrders.defaultExpectation = &LOMSRepositoryMockGetOldOrdersExpectation{mock: mmGetOldOrders.mock}
	}
	mmGetOldOrders.defaultExpectation.results = &LOMSRepositoryMockGetOldOrdersResults{oa1, err}
	return mmGetOldOrders.mock
}

// Set uses given function f to mock the LOMSRepository.GetOldOrders method
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) Set(f func(ctx context.Context, createdBefore time.Time) (oa1 []mm_domain.OrderID, err error)) *LOMSRepositoryMock {
	if mmGetOldOrders.defaultExpectation != nil {
		mmGetOldOrders.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.GetOldOrders method")
	}

	if len(mmGetOldOrders.expectations) > 0 {
		mmGetOldOrders.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.GetOldOrders method")
	}

	mmGetOldOrders.mock.funcGetOldOrders = f
	return mmGetOldOrders.mock
}

// When sets expectation for the LOMSRepository.GetOldOrders which will trigger the result defined by the following
// Then helper
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) When(ctx context.Context, createdBefore time.Time) *LOMSRepositoryMockGetOldOrdersExpectation {
	if mmGetOldOrders.mock.funcGetOldOrders != nil {
		mmGetOldOrders.mock.t.Fatalf("LOMSRepositoryMock.GetOldOrders mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockGetOldOrdersExpectation{
		mock:   mmGetOldOrders.mock,
		params: &LOMSRepositoryMockGetOldOrdersParams{ctx, createdBefore},
	}
	mmGetOldOrders.expectations = append(mmGetOldOrders.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.GetOldOrders return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockGetOldOrdersExpectation) Then(oa1 []mm_domain.OrderID, err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockGetOldOrdersResults{oa1, err}
	return e.mock
}

// GetOldOrders implements domain.LOMSRepository
func (mmGetOldOrders *LOMSRepositoryMock) GetOldOrders(ctx context.Context, createdBefore time.Time) (oa1 []mm_domain.OrderID, err error) {
	mm_atomic.AddUint64(&mmGetOldOrders.beforeGetOldOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOldOrders.afterGetOldOrdersCounter, 1)

	if mmGetOldOrders.inspectFuncGetOldOrders != nil {
		mmGetOldOrders.inspectFuncGetOldOrders(ctx, createdBefore)
	}

	mm_params := &LOMSRepositoryMockGetOldOrdersParams{ctx, createdBefore}

	// Record call args
	mmGetOldOrders.GetOldOrdersMock.mutex.Lock()
	mmGetOldOrders.GetOldOrdersMock.callArgs = append(mmGetOldOrders.GetOldOrdersMock.callArgs, mm_params)
	mmGetOldOrders.GetOldOrdersMock.mutex.Unlock()

	for _, e := range mmGetOldOrders.GetOldOrdersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOldOrders.GetOldOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOldOrders.GetOldOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOldOrders.GetOldOrdersMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockGetOldOrdersParams{ctx, createdBefore}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOldOrders.t.Errorf("LOMSRepositoryMock.GetOldOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOldOrders.GetOldOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOldOrders.t.Fatal("No results are set for the LOMSRepositoryMock.GetOldOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOldOrders.funcGetOldOrders != nil {
		return mmGetOldOrders.funcGetOldOrders(ctx, createdBefore)
	}
	mmGetOldOrders.t.Fatalf("Unexpected call to LOMSRepositoryMock.GetOldOrders. %v %v", ctx, createdBefore)
	return
}

// GetOldOrdersAfterCounter returns a count of finished LOMSRepositoryMock.GetOldOrders invocations
func (mmGetOldOrders *LOMSRepositoryMock) GetOldOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOldOrders.afterGetOldOrdersCounter)
}

// GetOldOrdersBeforeCounter returns a count of LOMSRepositoryMock.GetOldOrders invocations
func (mmGetOldOrders *LOMSRepositoryMock) GetOldOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOldOrders.beforeGetOldOrdersCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.GetOldOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOldOrders *mLOMSRepositoryMockGetOldOrders) Calls() []*LOMSRepositoryMockGetOldOrdersParams {
	mmGetOldOrders.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockGetOldOrdersParams, len(mmGetOldOrders.callArgs))
	copy(argCopy, mmGetOldOrders.callArgs)

	mmGetOldOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOldOrdersDone returns true if the count of the GetOldOrders invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockGetOldOrdersDone() bool {
	for _, e := range m.GetOldOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOldOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOldOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOldOrders != nil && mm_atomic.LoadUint64(&m.afterGetOldOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOldOrdersInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockGetOldOrdersInspect() {
	for _, e := range m.GetOldOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.GetOldOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOldOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOldOrdersCounter) < 1 {
		if m.GetOldOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.GetOldOrders")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.GetOldOrders with params: %#v", *m.GetOldOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOldOrders != nil && mm_atomic.LoadUint64(&m.afterGetOldOrdersCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.GetOldOrders")
	}
}

type mLOMSRepositoryMockGetStatus struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockGetStatusExpectation
	expectations       []*LOMSRepositoryMockGetStatusExpectation

	callArgs []*LOMSRepositoryMockGetStatusParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockGetStatusExpectation specifies expectation struct of the LOMSRepository.GetStatus
type LOMSRepositoryMockGetStatusExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockGetStatusParams
	results *LOMSRepositoryMockGetStatusResults
	Counter uint64
}

// LOMSRepositoryMockGetStatusParams contains parameters of the LOMSRepository.GetStatus
type LOMSRepositoryMockGetStatusParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
}

// LOMSRepositoryMockGetStatusResults contains results of the LOMSRepository.GetStatus
type LOMSRepositoryMockGetStatusResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LOMSRepository.GetStatus
func (mmGetStatus *mLOMSRepositoryMockGetStatus) Expect(ctx context.Context, orderID mm_domain.OrderID) *mLOMSRepositoryMockGetStatus {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("LOMSRepositoryMock.GetStatus mock is already set by Set")
	}

	if mmGetStatus.defaultExpectation == nil {
		mmGetStatus.defaultExpectation = &LOMSRepositoryMockGetStatusExpectation{}
	}

	mmGetStatus.defaultExpectation.params = &LOMSRepositoryMockGetStatusParams{ctx, orderID}
	for _, e := range mmGetStatus.expectations {
		if minimock.Equal(e.params, mmGetStatus.defaultExpectation.params) {
			mmGetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStatus.defaultExpectation.params)
		}
	}

	return mmGetStatus
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.GetStatus
func (mmGetStatus *mLOMSRepositoryMockGetStatus) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID)) *mLOMSRepositoryMockGetStatus {
	if mmGetStatus.mock.inspectFuncGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.GetStatus")
	}

	mmGetStatus.mock.inspectFuncGetStatus = f

	return mmGetStatus
}

// Return sets up results that will be returned by LOMSRepository.GetStatus
func (mmGetStatus *mLOMSRepositoryMockGetStatus) Return(s1 string, err error) *LOMSRepositoryMock {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("LOMSRepositoryMock.GetStatus mock is already set by Set")
	}

	if mmGetStatus.defaultExpectation == nil {
		mmGetStatus.defaultExpectation = &LOMSRepositoryMockGetStatusExpectation{mock: mmGetStatus.mock}
	}
	mmGetStatus.defaultExpectation.results = &LOMSRepositoryMockGetStatusResults{s1, err}
	return mmGetStatus.mock
}

// Set uses given function f to mock the LOMSRepository.GetStatus method
func (mmGetStatus *mLOMSRepositoryMockGetStatus) Set(f func(ctx context.Context, orderID mm_domain.OrderID) (s1 string, err error)) *LOMSRepositoryMock {
	if mmGetStatus.defaultExpectation != nil {
		mmGetStatus.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.GetStatus method")
	}

	if len(mmGetStatus.expectations) > 0 {
		mmGetStatus.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.GetStatus method")
	}

	mmGetStatus.mock.funcGetStatus = f
	return mmGetStatus.mock
}

// When sets expectation for the LOMSRepository.GetStatus which will trigger the result defined by the following
// Then helper
func (mmGetStatus *mLOMSRepositoryMockGetStatus) When(ctx context.Context, orderID mm_domain.OrderID) *LOMSRepositoryMockGetStatusExpectation {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("LOMSRepositoryMock.GetStatus mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockGetStatusExpectation{
		mock:   mmGetStatus.mock,
		params: &LOMSRepositoryMockGetStatusParams{ctx, orderID},
	}
	mmGetStatus.expectations = append(mmGetStatus.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.GetStatus return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockGetStatusExpectation) Then(s1 string, err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockGetStatusResults{s1, err}
	return e.mock
}

// GetStatus implements domain.LOMSRepository
func (mmGetStatus *LOMSRepositoryMock) GetStatus(ctx context.Context, orderID mm_domain.OrderID) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetStatus.beforeGetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatus.afterGetStatusCounter, 1)

	if mmGetStatus.inspectFuncGetStatus != nil {
		mmGetStatus.inspectFuncGetStatus(ctx, orderID)
	}

	mm_params := &LOMSRepositoryMockGetStatusParams{ctx, orderID}

	// Record call args
	mmGetStatus.GetStatusMock.mutex.Lock()
	mmGetStatus.GetStatusMock.callArgs = append(mmGetStatus.GetStatusMock.callArgs, mm_params)
	mmGetStatus.GetStatusMock.mutex.Unlock()

	for _, e := range mmGetStatus.GetStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStatus.GetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatus.GetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStatus.GetStatusMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockGetStatusParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStatus.t.Errorf("LOMSRepositoryMock.GetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStatus.GetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatus.t.Fatal("No results are set for the LOMSRepositoryMock.GetStatus")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStatus.funcGetStatus != nil {
		return mmGetStatus.funcGetStatus(ctx, orderID)
	}
	mmGetStatus.t.Fatalf("Unexpected call to LOMSRepositoryMock.GetStatus. %v %v", ctx, orderID)
	return
}

// GetStatusAfterCounter returns a count of finished LOMSRepositoryMock.GetStatus invocations
func (mmGetStatus *LOMSRepositoryMock) GetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatus.afterGetStatusCounter)
}

// GetStatusBeforeCounter returns a count of LOMSRepositoryMock.GetStatus invocations
func (mmGetStatus *LOMSRepositoryMock) GetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatus.beforeGetStatusCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.GetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStatus *mLOMSRepositoryMockGetStatus) Calls() []*LOMSRepositoryMockGetStatusParams {
	mmGetStatus.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockGetStatusParams, len(mmGetStatus.callArgs))
	copy(argCopy, mmGetStatus.callArgs)

	mmGetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetStatusDone returns true if the count of the GetStatus invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockGetStatusDone() bool {
	for _, e := range m.GetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatus != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStatusInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockGetStatusInspect() {
	for _, e := range m.GetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.GetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		if m.GetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.GetStatus")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.GetStatus with params: %#v", *m.GetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatus != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.GetStatus")
	}
}

type mLOMSRepositoryMockListOrder struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockListOrderExpectation
	expectations       []*LOMSRepositoryMockListOrderExpectation

	callArgs []*LOMSRepositoryMockListOrderParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockListOrderExpectation specifies expectation struct of the LOMSRepository.ListOrder
type LOMSRepositoryMockListOrderExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockListOrderParams
	results *LOMSRepositoryMockListOrderResults
	Counter uint64
}

// LOMSRepositoryMockListOrderParams contains parameters of the LOMSRepository.ListOrder
type LOMSRepositoryMockListOrderParams struct {
	ctx     context.Context
	orderID mm_domain.OrderID
}

// LOMSRepositoryMockListOrderResults contains results of the LOMSRepository.ListOrder
type LOMSRepositoryMockListOrderResults struct {
	o1  mm_domain.Order
	err error
}

// Expect sets up expected params for LOMSRepository.ListOrder
func (mmListOrder *mLOMSRepositoryMockListOrder) Expect(ctx context.Context, orderID mm_domain.OrderID) *mLOMSRepositoryMockListOrder {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("LOMSRepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &LOMSRepositoryMockListOrderExpectation{}
	}

	mmListOrder.defaultExpectation.params = &LOMSRepositoryMockListOrderParams{ctx, orderID}
	for _, e := range mmListOrder.expectations {
		if minimock.Equal(e.params, mmListOrder.defaultExpectation.params) {
			mmListOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrder.defaultExpectation.params)
		}
	}

	return mmListOrder
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.ListOrder
func (mmListOrder *mLOMSRepositoryMockListOrder) Inspect(f func(ctx context.Context, orderID mm_domain.OrderID)) *mLOMSRepositoryMockListOrder {
	if mmListOrder.mock.inspectFuncListOrder != nil {
		mmListOrder.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.ListOrder")
	}

	mmListOrder.mock.inspectFuncListOrder = f

	return mmListOrder
}

// Return sets up results that will be returned by LOMSRepository.ListOrder
func (mmListOrder *mLOMSRepositoryMockListOrder) Return(o1 mm_domain.Order, err error) *LOMSRepositoryMock {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("LOMSRepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &LOMSRepositoryMockListOrderExpectation{mock: mmListOrder.mock}
	}
	mmListOrder.defaultExpectation.results = &LOMSRepositoryMockListOrderResults{o1, err}
	return mmListOrder.mock
}

// Set uses given function f to mock the LOMSRepository.ListOrder method
func (mmListOrder *mLOMSRepositoryMockListOrder) Set(f func(ctx context.Context, orderID mm_domain.OrderID) (o1 mm_domain.Order, err error)) *LOMSRepositoryMock {
	if mmListOrder.defaultExpectation != nil {
		mmListOrder.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.ListOrder method")
	}

	if len(mmListOrder.expectations) > 0 {
		mmListOrder.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.ListOrder method")
	}

	mmListOrder.mock.funcListOrder = f
	return mmListOrder.mock
}

// When sets expectation for the LOMSRepository.ListOrder which will trigger the result defined by the following
// Then helper
func (mmListOrder *mLOMSRepositoryMockListOrder) When(ctx context.Context, orderID mm_domain.OrderID) *LOMSRepositoryMockListOrderExpectation {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("LOMSRepositoryMock.ListOrder mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockListOrderExpectation{
		mock:   mmListOrder.mock,
		params: &LOMSRepositoryMockListOrderParams{ctx, orderID},
	}
	mmListOrder.expectations = append(mmListOrder.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.ListOrder return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockListOrderExpectation) Then(o1 mm_domain.Order, err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockListOrderResults{o1, err}
	return e.mock
}

// ListOrder implements domain.LOMSRepository
func (mmListOrder *LOMSRepositoryMock) ListOrder(ctx context.Context, orderID mm_domain.OrderID) (o1 mm_domain.Order, err error) {
	mm_atomic.AddUint64(&mmListOrder.beforeListOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrder.afterListOrderCounter, 1)

	if mmListOrder.inspectFuncListOrder != nil {
		mmListOrder.inspectFuncListOrder(ctx, orderID)
	}

	mm_params := &LOMSRepositoryMockListOrderParams{ctx, orderID}

	// Record call args
	mmListOrder.ListOrderMock.mutex.Lock()
	mmListOrder.ListOrderMock.callArgs = append(mmListOrder.ListOrderMock.callArgs, mm_params)
	mmListOrder.ListOrderMock.mutex.Unlock()

	for _, e := range mmListOrder.ListOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmListOrder.ListOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrder.ListOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrder.ListOrderMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockListOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrder.t.Errorf("LOMSRepositoryMock.ListOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrder.ListOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrder.t.Fatal("No results are set for the LOMSRepositoryMock.ListOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmListOrder.funcListOrder != nil {
		return mmListOrder.funcListOrder(ctx, orderID)
	}
	mmListOrder.t.Fatalf("Unexpected call to LOMSRepositoryMock.ListOrder. %v %v", ctx, orderID)
	return
}

// ListOrderAfterCounter returns a count of finished LOMSRepositoryMock.ListOrder invocations
func (mmListOrder *LOMSRepositoryMock) ListOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.afterListOrderCounter)
}

// ListOrderBeforeCounter returns a count of LOMSRepositoryMock.ListOrder invocations
func (mmListOrder *LOMSRepositoryMock) ListOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.beforeListOrderCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.ListOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrder *mLOMSRepositoryMockListOrder) Calls() []*LOMSRepositoryMockListOrderParams {
	mmListOrder.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockListOrderParams, len(mmListOrder.callArgs))
	copy(argCopy, mmListOrder.callArgs)

	mmListOrder.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderDone returns true if the count of the ListOrder invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockListOrderDone() bool {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockListOrderInspect() {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.ListOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		if m.ListOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.ListOrder")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.ListOrder with params: %#v", *m.ListOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.ListOrder")
	}
}

type mLOMSRepositoryMockStocks struct {
	mock               *LOMSRepositoryMock
	defaultExpectation *LOMSRepositoryMockStocksExpectation
	expectations       []*LOMSRepositoryMockStocksExpectation

	callArgs []*LOMSRepositoryMockStocksParams
	mutex    sync.RWMutex
}

// LOMSRepositoryMockStocksExpectation specifies expectation struct of the LOMSRepository.Stocks
type LOMSRepositoryMockStocksExpectation struct {
	mock    *LOMSRepositoryMock
	params  *LOMSRepositoryMockStocksParams
	results *LOMSRepositoryMockStocksResults
	Counter uint64
}

// LOMSRepositoryMockStocksParams contains parameters of the LOMSRepository.Stocks
type LOMSRepositoryMockStocksParams struct {
	ctx context.Context
	sku uint32
}

// LOMSRepositoryMockStocksResults contains results of the LOMSRepository.Stocks
type LOMSRepositoryMockStocksResults struct {
	sa1 []mm_domain.Stock
	err error
}

// Expect sets up expected params for LOMSRepository.Stocks
func (mmStocks *mLOMSRepositoryMockStocks) Expect(ctx context.Context, sku uint32) *mLOMSRepositoryMockStocks {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("LOMSRepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &LOMSRepositoryMockStocksExpectation{}
	}

	mmStocks.defaultExpectation.params = &LOMSRepositoryMockStocksParams{ctx, sku}
	for _, e := range mmStocks.expectations {
		if minimock.Equal(e.params, mmStocks.defaultExpectation.params) {
			mmStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocks.defaultExpectation.params)
		}
	}

	return mmStocks
}

// Inspect accepts an inspector function that has same arguments as the LOMSRepository.Stocks
func (mmStocks *mLOMSRepositoryMockStocks) Inspect(f func(ctx context.Context, sku uint32)) *mLOMSRepositoryMockStocks {
	if mmStocks.mock.inspectFuncStocks != nil {
		mmStocks.mock.t.Fatalf("Inspect function is already set for LOMSRepositoryMock.Stocks")
	}

	mmStocks.mock.inspectFuncStocks = f

	return mmStocks
}

// Return sets up results that will be returned by LOMSRepository.Stocks
func (mmStocks *mLOMSRepositoryMockStocks) Return(sa1 []mm_domain.Stock, err error) *LOMSRepositoryMock {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("LOMSRepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &LOMSRepositoryMockStocksExpectation{mock: mmStocks.mock}
	}
	mmStocks.defaultExpectation.results = &LOMSRepositoryMockStocksResults{sa1, err}
	return mmStocks.mock
}

// Set uses given function f to mock the LOMSRepository.Stocks method
func (mmStocks *mLOMSRepositoryMockStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []mm_domain.Stock, err error)) *LOMSRepositoryMock {
	if mmStocks.defaultExpectation != nil {
		mmStocks.mock.t.Fatalf("Default expectation is already set for the LOMSRepository.Stocks method")
	}

	if len(mmStocks.expectations) > 0 {
		mmStocks.mock.t.Fatalf("Some expectations are already set for the LOMSRepository.Stocks method")
	}

	mmStocks.mock.funcStocks = f
	return mmStocks.mock
}

// When sets expectation for the LOMSRepository.Stocks which will trigger the result defined by the following
// Then helper
func (mmStocks *mLOMSRepositoryMockStocks) When(ctx context.Context, sku uint32) *LOMSRepositoryMockStocksExpectation {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("LOMSRepositoryMock.Stocks mock is already set by Set")
	}

	expectation := &LOMSRepositoryMockStocksExpectation{
		mock:   mmStocks.mock,
		params: &LOMSRepositoryMockStocksParams{ctx, sku},
	}
	mmStocks.expectations = append(mmStocks.expectations, expectation)
	return expectation
}

// Then sets up LOMSRepository.Stocks return parameters for the expectation previously defined by the When method
func (e *LOMSRepositoryMockStocksExpectation) Then(sa1 []mm_domain.Stock, err error) *LOMSRepositoryMock {
	e.results = &LOMSRepositoryMockStocksResults{sa1, err}
	return e.mock
}

// Stocks implements domain.LOMSRepository
func (mmStocks *LOMSRepositoryMock) Stocks(ctx context.Context, sku uint32) (sa1 []mm_domain.Stock, err error) {
	mm_atomic.AddUint64(&mmStocks.beforeStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmStocks.afterStocksCounter, 1)

	if mmStocks.inspectFuncStocks != nil {
		mmStocks.inspectFuncStocks(ctx, sku)
	}

	mm_params := &LOMSRepositoryMockStocksParams{ctx, sku}

	// Record call args
	mmStocks.StocksMock.mutex.Lock()
	mmStocks.StocksMock.callArgs = append(mmStocks.StocksMock.callArgs, mm_params)
	mmStocks.StocksMock.mutex.Unlock()

	for _, e := range mmStocks.StocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmStocks.StocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocks.StocksMock.defaultExpectation.Counter, 1)
		mm_want := mmStocks.StocksMock.defaultExpectation.params
		mm_got := LOMSRepositoryMockStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocks.t.Errorf("LOMSRepositoryMock.Stocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocks.StocksMock.defaultExpectation.results
		if mm_results == nil {
			mmStocks.t.Fatal("No results are set for the LOMSRepositoryMock.Stocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmStocks.funcStocks != nil {
		return mmStocks.funcStocks(ctx, sku)
	}
	mmStocks.t.Fatalf("Unexpected call to LOMSRepositoryMock.Stocks. %v %v", ctx, sku)
	return
}

// StocksAfterCounter returns a count of finished LOMSRepositoryMock.Stocks invocations
func (mmStocks *LOMSRepositoryMock) StocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.afterStocksCounter)
}

// StocksBeforeCounter returns a count of LOMSRepositoryMock.Stocks invocations
func (mmStocks *LOMSRepositoryMock) StocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.beforeStocksCounter)
}

// Calls returns a list of arguments used in each call to LOMSRepositoryMock.Stocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocks *mLOMSRepositoryMockStocks) Calls() []*LOMSRepositoryMockStocksParams {
	mmStocks.mutex.RLock()

	argCopy := make([]*LOMSRepositoryMockStocksParams, len(mmStocks.callArgs))
	copy(argCopy, mmStocks.callArgs)

	mmStocks.mutex.RUnlock()

	return argCopy
}

// MinimockStocksDone returns true if the count of the Stocks invocations corresponds
// the number of defined expectations
func (m *LOMSRepositoryMock) MinimockStocksDone() bool {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockStocksInspect logs each unmet expectation
func (m *LOMSRepositoryMock) MinimockStocksInspect() {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LOMSRepositoryMock.Stocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		if m.StocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LOMSRepositoryMock.Stocks")
		} else {
			m.t.Errorf("Expected call to LOMSRepositoryMock.Stocks with params: %#v", *m.StocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		m.t.Error("Expected call to LOMSRepositoryMock.Stocks")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LOMSRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelReserveInspect()

		m.MinimockChangeStatusInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockCreateReserveInspect()

		m.MinimockDeleteReserveInspect()

		m.MinimockGetOldOrdersInspect()

		m.MinimockGetStatusInspect()

		m.MinimockListOrderInspect()

		m.MinimockStocksInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LOMSRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LOMSRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelReserveDone() &&
		m.MinimockChangeStatusDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateReserveDone() &&
		m.MinimockDeleteReserveDone() &&
		m.MinimockGetOldOrdersDone() &&
		m.MinimockGetStatusDone() &&
		m.MinimockListOrderDone() &&
		m.MinimockStocksDone()
}
