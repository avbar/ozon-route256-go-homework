package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/jackc/pgx/v4.Tx -o ./mocks/tx_minimock.go -n TxMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	mm_pgx "github.com/jackc/pgx/v4"
)

// TxMock implements pgx.Tx
type TxMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context) (t1 mm_pgx.Tx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTxMockBegin

	funcBeginFunc          func(ctx context.Context, f func(mm_pgx.Tx) error) (err error)
	inspectFuncBeginFunc   func(ctx context.Context, f func(mm_pgx.Tx) error)
	afterBeginFuncCounter  uint64
	beforeBeginFuncCounter uint64
	BeginFuncMock          mTxMockBeginFunc

	funcCommit          func(ctx context.Context) (err error)
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTxMockCommit

	funcConn          func() (cp1 *mm_pgx.Conn)
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)
	inspectFuncCopyFrom   func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mTxMockExec

	funcLargeObjects          func() (l1 mm_pgx.LargeObjects)
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, sql string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mTxMockQuery

	funcQueryFunc          func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)
	inspectFuncQueryFunc   func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error)
	afterQueryFuncCounter  uint64
	beforeQueryFuncCounter uint64
	QueryFuncMock          mTxMockQueryFunc

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTxMockRollback

	funcSendBatch          func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)
	inspectFuncSendBatch   func(ctx context.Context, b *mm_pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mTxMockSendBatch
}

// NewTxMock returns a mock for pgx.Tx
func NewTxMock(t minimock.Tester) *TxMock {
	m := &TxMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*TxMockBeginParams{}

	m.BeginFuncMock = mTxMockBeginFunc{mock: m}
	m.BeginFuncMock.callArgs = []*TxMockBeginFuncParams{}

	m.CommitMock = mTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*TxMockCommitParams{}

	m.ConnMock = mTxMockConn{mock: m}

	m.CopyFromMock = mTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*TxMockCopyFromParams{}

	m.ExecMock = mTxMockExec{mock: m}
	m.ExecMock.callArgs = []*TxMockExecParams{}

	m.LargeObjectsMock = mTxMockLargeObjects{mock: m}

	m.PrepareMock = mTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*TxMockPrepareParams{}

	m.QueryMock = mTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*TxMockQueryParams{}

	m.QueryFuncMock = mTxMockQueryFunc{mock: m}
	m.QueryFuncMock.callArgs = []*TxMockQueryFuncParams{}

	m.QueryRowMock = mTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*TxMockQueryRowParams{}

	m.RollbackMock = mTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*TxMockRollbackParams{}

	m.SendBatchMock = mTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*TxMockSendBatchParams{}

	return m
}

type mTxMockBegin struct {
	mock               *TxMock
	defaultExpectation *TxMockBeginExpectation
	expectations       []*TxMockBeginExpectation

	callArgs []*TxMockBeginParams
	mutex    sync.RWMutex
}

// TxMockBeginExpectation specifies expectation struct of the Tx.Begin
type TxMockBeginExpectation struct {
	mock    *TxMock
	params  *TxMockBeginParams
	results *TxMockBeginResults
	Counter uint64
}

// TxMockBeginParams contains parameters of the Tx.Begin
type TxMockBeginParams struct {
	ctx context.Context
}

// TxMockBeginResults contains results of the Tx.Begin
type TxMockBeginResults struct {
	t1  mm_pgx.Tx
	err error
}

// Expect sets up expected params for Tx.Begin
func (mmBegin *mTxMockBegin) Expect(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &TxMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Tx.Begin
func (mmBegin *mTxMockBegin) Inspect(f func(ctx context.Context)) *mTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Tx.Begin
func (mmBegin *mTxMockBegin) Return(t1 mm_pgx.Tx, err error) *TxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TxMockBeginResults{t1, err}
	return mmBegin.mock
}

// Set uses given function f to mock the Tx.Begin method
func (mmBegin *mTxMockBegin) Set(f func(ctx context.Context) (t1 mm_pgx.Tx, err error)) *TxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Tx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Tx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the Tx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mTxMockBegin) When(ctx context.Context) *TxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	expectation := &TxMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &TxMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Tx.Begin return parameters for the expectation previously defined by the When method
func (e *TxMockBeginExpectation) Then(t1 mm_pgx.Tx, err error) *TxMock {
	e.results = &TxMockBeginResults{t1, err}
	return e.mock
}

// Begin implements pgx.Tx
func (mmBegin *TxMock) Begin(ctx context.Context) (t1 mm_pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := &TxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_got := TxMockBeginParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("TxMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to TxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished TxMock.Begin invocations
func (mmBegin *TxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TxMock.Begin invocations
func (mmBegin *TxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mTxMockBegin) Calls() []*TxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*TxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *TxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Begin")
		} else {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to TxMock.Begin")
	}
}

type mTxMockBeginFunc struct {
	mock               *TxMock
	defaultExpectation *TxMockBeginFuncExpectation
	expectations       []*TxMockBeginFuncExpectation

	callArgs []*TxMockBeginFuncParams
	mutex    sync.RWMutex
}

// TxMockBeginFuncExpectation specifies expectation struct of the Tx.BeginFunc
type TxMockBeginFuncExpectation struct {
	mock    *TxMock
	params  *TxMockBeginFuncParams
	results *TxMockBeginFuncResults
	Counter uint64
}

// TxMockBeginFuncParams contains parameters of the Tx.BeginFunc
type TxMockBeginFuncParams struct {
	ctx context.Context
	f   func(mm_pgx.Tx) error
}

// TxMockBeginFuncResults contains results of the Tx.BeginFunc
type TxMockBeginFuncResults struct {
	err error
}

// Expect sets up expected params for Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Expect(ctx context.Context, f func(mm_pgx.Tx) error) *mTxMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{}
	}

	mmBeginFunc.defaultExpectation.params = &TxMockBeginFuncParams{ctx, f}
	for _, e := range mmBeginFunc.expectations {
		if minimock.Equal(e.params, mmBeginFunc.defaultExpectation.params) {
			mmBeginFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginFunc.defaultExpectation.params)
		}
	}

	return mmBeginFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Inspect(f func(ctx context.Context, f func(mm_pgx.Tx) error)) *mTxMockBeginFunc {
	if mmBeginFunc.mock.inspectFuncBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("Inspect function is already set for TxMock.BeginFunc")
	}

	mmBeginFunc.mock.inspectFuncBeginFunc = f

	return mmBeginFunc
}

// Return sets up results that will be returned by Tx.BeginFunc
func (mmBeginFunc *mTxMockBeginFunc) Return(err error) *TxMock {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &TxMockBeginFuncExpectation{mock: mmBeginFunc.mock}
	}
	mmBeginFunc.defaultExpectation.results = &TxMockBeginFuncResults{err}
	return mmBeginFunc.mock
}

// Set uses given function f to mock the Tx.BeginFunc method
func (mmBeginFunc *mTxMockBeginFunc) Set(f func(ctx context.Context, f func(mm_pgx.Tx) error) (err error)) *TxMock {
	if mmBeginFunc.defaultExpectation != nil {
		mmBeginFunc.mock.t.Fatalf("Default expectation is already set for the Tx.BeginFunc method")
	}

	if len(mmBeginFunc.expectations) > 0 {
		mmBeginFunc.mock.t.Fatalf("Some expectations are already set for the Tx.BeginFunc method")
	}

	mmBeginFunc.mock.funcBeginFunc = f
	return mmBeginFunc.mock
}

// When sets expectation for the Tx.BeginFunc which will trigger the result defined by the following
// Then helper
func (mmBeginFunc *mTxMockBeginFunc) When(ctx context.Context, f func(mm_pgx.Tx) error) *TxMockBeginFuncExpectation {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("TxMock.BeginFunc mock is already set by Set")
	}

	expectation := &TxMockBeginFuncExpectation{
		mock:   mmBeginFunc.mock,
		params: &TxMockBeginFuncParams{ctx, f},
	}
	mmBeginFunc.expectations = append(mmBeginFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.BeginFunc return parameters for the expectation previously defined by the When method
func (e *TxMockBeginFuncExpectation) Then(err error) *TxMock {
	e.results = &TxMockBeginFuncResults{err}
	return e.mock
}

// BeginFunc implements pgx.Tx
func (mmBeginFunc *TxMock) BeginFunc(ctx context.Context, f func(mm_pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmBeginFunc.beforeBeginFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginFunc.afterBeginFuncCounter, 1)

	if mmBeginFunc.inspectFuncBeginFunc != nil {
		mmBeginFunc.inspectFuncBeginFunc(ctx, f)
	}

	mm_params := &TxMockBeginFuncParams{ctx, f}

	// Record call args
	mmBeginFunc.BeginFuncMock.mutex.Lock()
	mmBeginFunc.BeginFuncMock.callArgs = append(mmBeginFunc.BeginFuncMock.callArgs, mm_params)
	mmBeginFunc.BeginFuncMock.mutex.Unlock()

	for _, e := range mmBeginFunc.BeginFuncMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBeginFunc.BeginFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginFunc.BeginFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginFunc.BeginFuncMock.defaultExpectation.params
		mm_got := TxMockBeginFuncParams{ctx, f}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginFunc.t.Errorf("TxMock.BeginFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginFunc.BeginFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginFunc.t.Fatal("No results are set for the TxMock.BeginFunc")
		}
		return (*mm_results).err
	}
	if mmBeginFunc.funcBeginFunc != nil {
		return mmBeginFunc.funcBeginFunc(ctx, f)
	}
	mmBeginFunc.t.Fatalf("Unexpected call to TxMock.BeginFunc. %v %v", ctx, f)
	return
}

// BeginFuncAfterCounter returns a count of finished TxMock.BeginFunc invocations
func (mmBeginFunc *TxMock) BeginFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.afterBeginFuncCounter)
}

// BeginFuncBeforeCounter returns a count of TxMock.BeginFunc invocations
func (mmBeginFunc *TxMock) BeginFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.beforeBeginFuncCounter)
}

// Calls returns a list of arguments used in each call to TxMock.BeginFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginFunc *mTxMockBeginFunc) Calls() []*TxMockBeginFuncParams {
	mmBeginFunc.mutex.RLock()

	argCopy := make([]*TxMockBeginFuncParams, len(mmBeginFunc.callArgs))
	copy(argCopy, mmBeginFunc.callArgs)

	mmBeginFunc.mutex.RUnlock()

	return argCopy
}

// MinimockBeginFuncDone returns true if the count of the BeginFunc invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginFuncDone() bool {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginFuncInspect logs each unmet expectation
func (m *TxMock) MinimockBeginFuncInspect() {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.BeginFunc with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		if m.BeginFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.BeginFunc")
		} else {
			m.t.Errorf("Expected call to TxMock.BeginFunc with params: %#v", *m.BeginFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		m.t.Error("Expected call to TxMock.BeginFunc")
	}
}

type mTxMockCommit struct {
	mock               *TxMock
	defaultExpectation *TxMockCommitExpectation
	expectations       []*TxMockCommitExpectation

	callArgs []*TxMockCommitParams
	mutex    sync.RWMutex
}

// TxMockCommitExpectation specifies expectation struct of the Tx.Commit
type TxMockCommitExpectation struct {
	mock    *TxMock
	params  *TxMockCommitParams
	results *TxMockCommitResults
	Counter uint64
}

// TxMockCommitParams contains parameters of the Tx.Commit
type TxMockCommitParams struct {
	ctx context.Context
}

// TxMockCommitResults contains results of the Tx.Commit
type TxMockCommitResults struct {
	err error
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTxMockCommit) Expect(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	mmCommit.defaultExpectation.params = &TxMockCommitParams{ctx}
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTxMockCommit) Inspect(f func(ctx context.Context)) *mTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTxMockCommit) Return(err error) *TxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TxMockCommitResults{err}
	return mmCommit.mock
}

// Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTxMockCommit) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// When sets expectation for the Tx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mTxMockCommit) When(ctx context.Context) *TxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	expectation := &TxMockCommitExpectation{
		mock:   mmCommit.mock,
		params: &TxMockCommitParams{ctx},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up Tx.Commit return parameters for the expectation previously defined by the When method
func (e *TxMockCommitExpectation) Then(err error) *TxMock {
	e.results = &TxMockCommitResults{err}
	return e.mock
}

// Commit implements pgx.Tx
func (mmCommit *TxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := &TxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_got := TxMockCommitParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("TxMock.Commit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to TxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished TxMock.Commit invocations
func (mmCommit *TxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TxMock.Commit invocations
func (mmCommit *TxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mTxMockCommit) Calls() []*TxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*TxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *TxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Commit")
		} else {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to TxMock.Commit")
	}
}

type mTxMockConn struct {
	mock               *TxMock
	defaultExpectation *TxMockConnExpectation
	expectations       []*TxMockConnExpectation
}

// TxMockConnExpectation specifies expectation struct of the Tx.Conn
type TxMockConnExpectation struct {
	mock *TxMock

	results *TxMockConnResults
	Counter uint64
}

// TxMockConnResults contains results of the Tx.Conn
type TxMockConnResults struct {
	cp1 *mm_pgx.Conn
}

// Expect sets up expected params for Tx.Conn
func (mmConn *mTxMockConn) Expect() *mTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the Tx.Conn
func (mmConn *mTxMockConn) Inspect(f func()) *mTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for TxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by Tx.Conn
func (mmConn *mTxMockConn) Return(cp1 *mm_pgx.Conn) *TxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &TxMockConnResults{cp1}
	return mmConn.mock
}

// Set uses given function f to mock the Tx.Conn method
func (mmConn *mTxMockConn) Set(f func() (cp1 *mm_pgx.Conn)) *TxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the Tx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the Tx.Conn method")
	}

	mmConn.mock.funcConn = f
	return mmConn.mock
}

// Conn implements pgx.Tx
func (mmConn *TxMock) Conn() (cp1 *mm_pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the TxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to TxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished TxMock.Conn invocations
func (mmConn *TxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of TxMock.Conn invocations
func (mmConn *TxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockConnDone() bool {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnInspect logs each unmet expectation
func (m *TxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Conn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}
}

type mTxMockCopyFrom struct {
	mock               *TxMock
	defaultExpectation *TxMockCopyFromExpectation
	expectations       []*TxMockCopyFromExpectation

	callArgs []*TxMockCopyFromParams
	mutex    sync.RWMutex
}

// TxMockCopyFromExpectation specifies expectation struct of the Tx.CopyFrom
type TxMockCopyFromExpectation struct {
	mock    *TxMock
	params  *TxMockCopyFromParams
	results *TxMockCopyFromResults
	Counter uint64
}

// TxMockCopyFromParams contains parameters of the Tx.CopyFrom
type TxMockCopyFromParams struct {
	ctx         context.Context
	tableName   mm_pgx.Identifier
	columnNames []string
	rowSrc      mm_pgx.CopyFromSource
}

// TxMockCopyFromResults contains results of the Tx.CopyFrom
type TxMockCopyFromResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Expect(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	mmCopyFrom.defaultExpectation.params = &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)) *mTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for TxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Return(i1 int64, err error) *TxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &TxMockCopyFromResults{i1, err}
	return mmCopyFrom.mock
}

// Set uses given function f to mock the Tx.CopyFrom method
func (mmCopyFrom *mTxMockCopyFrom) Set(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)) *TxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the Tx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the Tx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	return mmCopyFrom.mock
}

// When sets expectation for the Tx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mTxMockCopyFrom) When(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *TxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	expectation := &TxMockCopyFromExpectation{
		mock:   mmCopyFrom.mock,
		params: &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up Tx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *TxMockCopyFromExpectation) Then(i1 int64, err error) *TxMock {
	e.results = &TxMockCopyFromResults{i1, err}
	return e.mock
}

// CopyFrom implements pgx.Tx
func (mmCopyFrom *TxMock) CopyFrom(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_got := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the TxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to TxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to TxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mTxMockCopyFrom) Calls() []*TxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*TxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCopyFromDone() bool {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *TxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.CopyFrom")
		} else {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		m.t.Error("Expected call to TxMock.CopyFrom")
	}
}

type mTxMockExec struct {
	mock               *TxMock
	defaultExpectation *TxMockExecExpectation
	expectations       []*TxMockExecExpectation

	callArgs []*TxMockExecParams
	mutex    sync.RWMutex
}

// TxMockExecExpectation specifies expectation struct of the Tx.Exec
type TxMockExecExpectation struct {
	mock    *TxMock
	params  *TxMockExecParams
	results *TxMockExecResults
	Counter uint64
}

// TxMockExecParams contains parameters of the Tx.Exec
type TxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []interface{}
}

// TxMockExecResults contains results of the Tx.Exec
type TxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// Expect sets up expected params for Tx.Exec
func (mmExec *mTxMockExec) Expect(ctx context.Context, sql string, arguments ...interface{}) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &TxMockExecParams{ctx, sql, arguments}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Tx.Exec
func (mmExec *mTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...interface{})) *mTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for TxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Tx.Exec
func (mmExec *mTxMockExec) Return(commandTag pgconn.CommandTag, err error) *TxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &TxMockExecResults{commandTag, err}
	return mmExec.mock
}

// Set uses given function f to mock the Tx.Exec method
func (mmExec *mTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)) *TxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Tx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Tx.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the Tx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mTxMockExec) When(ctx context.Context, sql string, arguments ...interface{}) *TxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	expectation := &TxMockExecExpectation{
		mock:   mmExec.mock,
		params: &TxMockExecParams{ctx, sql, arguments},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Tx.Exec return parameters for the expectation previously defined by the When method
func (e *TxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockExecResults{commandTag, err}
	return e.mock
}

// Exec implements pgx.Tx
func (mmExec *TxMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := &TxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := TxMockExecParams{ctx, sql, arguments}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("TxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the TxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to TxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished TxMock.Exec invocations
func (mmExec *TxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of TxMock.Exec invocations
func (mmExec *TxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mTxMockExec) Calls() []*TxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*TxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *TxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Exec")
		} else {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to TxMock.Exec")
	}
}

type mTxMockLargeObjects struct {
	mock               *TxMock
	defaultExpectation *TxMockLargeObjectsExpectation
	expectations       []*TxMockLargeObjectsExpectation
}

// TxMockLargeObjectsExpectation specifies expectation struct of the Tx.LargeObjects
type TxMockLargeObjectsExpectation struct {
	mock *TxMock

	results *TxMockLargeObjectsResults
	Counter uint64
}

// TxMockLargeObjectsResults contains results of the Tx.LargeObjects
type TxMockLargeObjectsResults struct {
	l1 mm_pgx.LargeObjects
}

// Expect sets up expected params for Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Expect() *mTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Inspect(f func()) *mTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for TxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Return(l1 mm_pgx.LargeObjects) *TxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &TxMockLargeObjectsResults{l1}
	return mmLargeObjects.mock
}

// Set uses given function f to mock the Tx.LargeObjects method
func (mmLargeObjects *mTxMockLargeObjects) Set(f func() (l1 mm_pgx.LargeObjects)) *TxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the Tx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the Tx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	return mmLargeObjects.mock
}

// LargeObjects implements pgx.Tx
func (mmLargeObjects *TxMock) LargeObjects() (l1 mm_pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the TxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to TxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockLargeObjectsDone() bool {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *TxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.LargeObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}
}

type mTxMockPrepare struct {
	mock               *TxMock
	defaultExpectation *TxMockPrepareExpectation
	expectations       []*TxMockPrepareExpectation

	callArgs []*TxMockPrepareParams
	mutex    sync.RWMutex
}

// TxMockPrepareExpectation specifies expectation struct of the Tx.Prepare
type TxMockPrepareExpectation struct {
	mock    *TxMock
	params  *TxMockPrepareParams
	results *TxMockPrepareResults
	Counter uint64
}

// TxMockPrepareParams contains parameters of the Tx.Prepare
type TxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// TxMockPrepareResults contains results of the Tx.Prepare
type TxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// Expect sets up expected params for Tx.Prepare
func (mmPrepare *mTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	mmPrepare.defaultExpectation.params = &TxMockPrepareParams{ctx, name, sql}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the Tx.Prepare
func (mmPrepare *mTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for TxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by Tx.Prepare
func (mmPrepare *mTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *TxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &TxMockPrepareResults{sp1, err}
	return mmPrepare.mock
}

// Set uses given function f to mock the Tx.Prepare method
func (mmPrepare *mTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *TxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the Tx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the Tx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the Tx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mTxMockPrepare) When(ctx context.Context, name string, sql string) *TxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	expectation := &TxMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &TxMockPrepareParams{ctx, name, sql},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up Tx.Prepare return parameters for the expectation previously defined by the When method
func (e *TxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *TxMock {
	e.results = &TxMockPrepareResults{sp1, err}
	return e.mock
}

// Prepare implements pgx.Tx
func (mmPrepare *TxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := &TxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_got := TxMockPrepareParams{ctx, name, sql}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the TxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to TxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mTxMockPrepare) Calls() []*TxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*TxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *TxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to TxMock.Prepare")
	}
}

type mTxMockQuery struct {
	mock               *TxMock
	defaultExpectation *TxMockQueryExpectation
	expectations       []*TxMockQueryExpectation

	callArgs []*TxMockQueryParams
	mutex    sync.RWMutex
}

// TxMockQueryExpectation specifies expectation struct of the Tx.Query
type TxMockQueryExpectation struct {
	mock    *TxMock
	params  *TxMockQueryParams
	results *TxMockQueryResults
	Counter uint64
}

// TxMockQueryParams contains parameters of the Tx.Query
type TxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TxMockQueryResults contains results of the Tx.Query
type TxMockQueryResults struct {
	r1  mm_pgx.Rows
	err error
}

// Expect sets up expected params for Tx.Query
func (mmQuery *mTxMockQuery) Expect(ctx context.Context, sql string, args ...interface{}) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &TxMockQueryParams{ctx, sql, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Tx.Query
func (mmQuery *mTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for TxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Tx.Query
func (mmQuery *mTxMockQuery) Return(r1 mm_pgx.Rows, err error) *TxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &TxMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the Tx.Query method
func (mmQuery *mTxMockQuery) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error)) *TxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Tx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Tx.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the Tx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mTxMockQuery) When(ctx context.Context, sql string, args ...interface{}) *TxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	expectation := &TxMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &TxMockQueryParams{ctx, sql, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Tx.Query return parameters for the expectation previously defined by the When method
func (e *TxMockQueryExpectation) Then(r1 mm_pgx.Rows, err error) *TxMock {
	e.results = &TxMockQueryResults{r1, err}
	return e.mock
}

// Query implements pgx.Tx
func (mmQuery *TxMock) Query(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := &TxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := TxMockQueryParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("TxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the TxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to TxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished TxMock.Query invocations
func (mmQuery *TxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of TxMock.Query invocations
func (mmQuery *TxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mTxMockQuery) Calls() []*TxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*TxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *TxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Query")
		} else {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to TxMock.Query")
	}
}

type mTxMockQueryFunc struct {
	mock               *TxMock
	defaultExpectation *TxMockQueryFuncExpectation
	expectations       []*TxMockQueryFuncExpectation

	callArgs []*TxMockQueryFuncParams
	mutex    sync.RWMutex
}

// TxMockQueryFuncExpectation specifies expectation struct of the Tx.QueryFunc
type TxMockQueryFuncExpectation struct {
	mock    *TxMock
	params  *TxMockQueryFuncParams
	results *TxMockQueryFuncResults
	Counter uint64
}

// TxMockQueryFuncParams contains parameters of the Tx.QueryFunc
type TxMockQueryFuncParams struct {
	ctx   context.Context
	sql   string
	args  []interface{}
	scans []interface{}
	f     func(mm_pgx.QueryFuncRow) error
}

// TxMockQueryFuncResults contains results of the Tx.QueryFunc
type TxMockQueryFuncResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Expect(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) *mTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{}
	}

	mmQueryFunc.defaultExpectation.params = &TxMockQueryFuncParams{ctx, sql, args, scans, f}
	for _, e := range mmQueryFunc.expectations {
		if minimock.Equal(e.params, mmQueryFunc.defaultExpectation.params) {
			mmQueryFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryFunc.defaultExpectation.params)
		}
	}

	return mmQueryFunc
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Inspect(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error)) *mTxMockQueryFunc {
	if mmQueryFunc.mock.inspectFuncQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("Inspect function is already set for TxMock.QueryFunc")
	}

	mmQueryFunc.mock.inspectFuncQueryFunc = f

	return mmQueryFunc
}

// Return sets up results that will be returned by Tx.QueryFunc
func (mmQueryFunc *mTxMockQueryFunc) Return(c2 pgconn.CommandTag, err error) *TxMock {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &TxMockQueryFuncExpectation{mock: mmQueryFunc.mock}
	}
	mmQueryFunc.defaultExpectation.results = &TxMockQueryFuncResults{c2, err}
	return mmQueryFunc.mock
}

// Set uses given function f to mock the Tx.QueryFunc method
func (mmQueryFunc *mTxMockQueryFunc) Set(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)) *TxMock {
	if mmQueryFunc.defaultExpectation != nil {
		mmQueryFunc.mock.t.Fatalf("Default expectation is already set for the Tx.QueryFunc method")
	}

	if len(mmQueryFunc.expectations) > 0 {
		mmQueryFunc.mock.t.Fatalf("Some expectations are already set for the Tx.QueryFunc method")
	}

	mmQueryFunc.mock.funcQueryFunc = f
	return mmQueryFunc.mock
}

// When sets expectation for the Tx.QueryFunc which will trigger the result defined by the following
// Then helper
func (mmQueryFunc *mTxMockQueryFunc) When(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) *TxMockQueryFuncExpectation {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("TxMock.QueryFunc mock is already set by Set")
	}

	expectation := &TxMockQueryFuncExpectation{
		mock:   mmQueryFunc.mock,
		params: &TxMockQueryFuncParams{ctx, sql, args, scans, f},
	}
	mmQueryFunc.expectations = append(mmQueryFunc.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryFunc return parameters for the expectation previously defined by the When method
func (e *TxMockQueryFuncExpectation) Then(c2 pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockQueryFuncResults{c2, err}
	return e.mock
}

// QueryFunc implements pgx.Tx
func (mmQueryFunc *TxMock) QueryFunc(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(mm_pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmQueryFunc.beforeQueryFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryFunc.afterQueryFuncCounter, 1)

	if mmQueryFunc.inspectFuncQueryFunc != nil {
		mmQueryFunc.inspectFuncQueryFunc(ctx, sql, args, scans, f)
	}

	mm_params := &TxMockQueryFuncParams{ctx, sql, args, scans, f}

	// Record call args
	mmQueryFunc.QueryFuncMock.mutex.Lock()
	mmQueryFunc.QueryFuncMock.callArgs = append(mmQueryFunc.QueryFuncMock.callArgs, mm_params)
	mmQueryFunc.QueryFuncMock.mutex.Unlock()

	for _, e := range mmQueryFunc.QueryFuncMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmQueryFunc.QueryFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryFunc.QueryFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryFunc.QueryFuncMock.defaultExpectation.params
		mm_got := TxMockQueryFuncParams{ctx, sql, args, scans, f}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryFunc.t.Errorf("TxMock.QueryFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryFunc.QueryFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryFunc.t.Fatal("No results are set for the TxMock.QueryFunc")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmQueryFunc.funcQueryFunc != nil {
		return mmQueryFunc.funcQueryFunc(ctx, sql, args, scans, f)
	}
	mmQueryFunc.t.Fatalf("Unexpected call to TxMock.QueryFunc. %v %v %v %v %v", ctx, sql, args, scans, f)
	return
}

// QueryFuncAfterCounter returns a count of finished TxMock.QueryFunc invocations
func (mmQueryFunc *TxMock) QueryFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.afterQueryFuncCounter)
}

// QueryFuncBeforeCounter returns a count of TxMock.QueryFunc invocations
func (mmQueryFunc *TxMock) QueryFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.beforeQueryFuncCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryFunc *mTxMockQueryFunc) Calls() []*TxMockQueryFuncParams {
	mmQueryFunc.mutex.RLock()

	argCopy := make([]*TxMockQueryFuncParams, len(mmQueryFunc.callArgs))
	copy(argCopy, mmQueryFunc.callArgs)

	mmQueryFunc.mutex.RUnlock()

	return argCopy
}

// MinimockQueryFuncDone returns true if the count of the QueryFunc invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryFuncDone() bool {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryFuncInspect logs each unmet expectation
func (m *TxMock) MinimockQueryFuncInspect() {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryFunc with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		if m.QueryFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.QueryFunc")
		} else {
			m.t.Errorf("Expected call to TxMock.QueryFunc with params: %#v", *m.QueryFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		m.t.Error("Expected call to TxMock.QueryFunc")
	}
}

type mTxMockQueryRow struct {
	mock               *TxMock
	defaultExpectation *TxMockQueryRowExpectation
	expectations       []*TxMockQueryRowExpectation

	callArgs []*TxMockQueryRowParams
	mutex    sync.RWMutex
}

// TxMockQueryRowExpectation specifies expectation struct of the Tx.QueryRow
type TxMockQueryRowExpectation struct {
	mock    *TxMock
	params  *TxMockQueryRowParams
	results *TxMockQueryRowResults
	Counter uint64
}

// TxMockQueryRowParams contains parameters of the Tx.QueryRow
type TxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TxMockQueryRowResults contains results of the Tx.QueryRow
type TxMockQueryRowResults struct {
	r1 mm_pgx.Row
}

// Expect sets up expected params for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	mmQueryRow.defaultExpectation.params = &TxMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for TxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Return(r1 mm_pgx.Row) *TxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &TxMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the Tx.QueryRow method
func (mmQueryRow *mTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row)) *TxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the Tx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the Tx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the Tx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mTxMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *TxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	expectation := &TxMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &TxMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryRow return parameters for the expectation previously defined by the When method
func (e *TxMockQueryRowExpectation) Then(r1 mm_pgx.Row) *TxMock {
	e.results = &TxMockQueryRowResults{r1}
	return e.mock
}

// QueryRow implements pgx.Tx
func (mmQueryRow *TxMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 mm_pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := &TxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_got := TxMockQueryRowParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the TxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to TxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mTxMockQueryRow) Calls() []*TxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*TxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryRowDone() bool {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *TxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		m.t.Error("Expected call to TxMock.QueryRow")
	}
}

type mTxMockRollback struct {
	mock               *TxMock
	defaultExpectation *TxMockRollbackExpectation
	expectations       []*TxMockRollbackExpectation

	callArgs []*TxMockRollbackParams
	mutex    sync.RWMutex
}

// TxMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TxMockRollbackExpectation struct {
	mock    *TxMock
	params  *TxMockRollbackParams
	results *TxMockRollbackResults
	Counter uint64
}

// TxMockRollbackParams contains parameters of the Tx.Rollback
type TxMockRollbackParams struct {
	ctx context.Context
}

// TxMockRollbackResults contains results of the Tx.Rollback
type TxMockRollbackResults struct {
	err error
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTxMockRollback) Expect(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	mmRollback.defaultExpectation.params = &TxMockRollbackParams{ctx}
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTxMockRollback) Inspect(f func(ctx context.Context)) *mTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTxMockRollback) Return(err error) *TxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TxMockRollbackResults{err}
	return mmRollback.mock
}

// Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTxMockRollback) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// When sets expectation for the Tx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mTxMockRollback) When(ctx context.Context) *TxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	expectation := &TxMockRollbackExpectation{
		mock:   mmRollback.mock,
		params: &TxMockRollbackParams{ctx},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up Tx.Rollback return parameters for the expectation previously defined by the When method
func (e *TxMockRollbackExpectation) Then(err error) *TxMock {
	e.results = &TxMockRollbackResults{err}
	return e.mock
}

// Rollback implements pgx.Tx
func (mmRollback *TxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := &TxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_got := TxMockRollbackParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("TxMock.Rollback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to TxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mTxMockRollback) Calls() []*TxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*TxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Rollback")
		} else {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to TxMock.Rollback")
	}
}

type mTxMockSendBatch struct {
	mock               *TxMock
	defaultExpectation *TxMockSendBatchExpectation
	expectations       []*TxMockSendBatchExpectation

	callArgs []*TxMockSendBatchParams
	mutex    sync.RWMutex
}

// TxMockSendBatchExpectation specifies expectation struct of the Tx.SendBatch
type TxMockSendBatchExpectation struct {
	mock    *TxMock
	params  *TxMockSendBatchParams
	results *TxMockSendBatchResults
	Counter uint64
}

// TxMockSendBatchParams contains parameters of the Tx.SendBatch
type TxMockSendBatchParams struct {
	ctx context.Context
	b   *mm_pgx.Batch
}

// TxMockSendBatchResults contains results of the Tx.SendBatch
type TxMockSendBatchResults struct {
	b1 mm_pgx.BatchResults
}

// Expect sets up expected params for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Expect(ctx context.Context, b *mm_pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	mmSendBatch.defaultExpectation.params = &TxMockSendBatchParams{ctx, b}
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Inspect(f func(ctx context.Context, b *mm_pgx.Batch)) *mTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for TxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Return(b1 mm_pgx.BatchResults) *TxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &TxMockSendBatchResults{b1}
	return mmSendBatch.mock
}

// Set uses given function f to mock the Tx.SendBatch method
func (mmSendBatch *mTxMockSendBatch) Set(f func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)) *TxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Tx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Tx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	return mmSendBatch.mock
}

// When sets expectation for the Tx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mTxMockSendBatch) When(ctx context.Context, b *mm_pgx.Batch) *TxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	expectation := &TxMockSendBatchExpectation{
		mock:   mmSendBatch.mock,
		params: &TxMockSendBatchParams{ctx, b},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Tx.SendBatch return parameters for the expectation previously defined by the When method
func (e *TxMockSendBatchExpectation) Then(b1 mm_pgx.BatchResults) *TxMock {
	e.results = &TxMockSendBatchResults{b1}
	return e.mock
}

// SendBatch implements pgx.Tx
func (mmSendBatch *TxMock) SendBatch(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := &TxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_got := TxMockSendBatchParams{ctx, b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the TxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to TxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to TxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mTxMockSendBatch) Calls() []*TxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*TxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockSendBatchDone() bool {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *TxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.SendBatch")
		} else {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		m.t.Error("Expected call to TxMock.SendBatch")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockBeginFuncInspect()

		m.MinimockCommitInspect()

		m.MinimockConnInspect()

		m.MinimockCopyFromInspect()

		m.MinimockExecInspect()

		m.MinimockLargeObjectsInspect()

		m.MinimockPrepareInspect()

		m.MinimockQueryInspect()

		m.MinimockQueryFuncInspect()

		m.MinimockQueryRowInspect()

		m.MinimockRollbackInspect()

		m.MinimockSendBatchInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockBeginFuncDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryFuncDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
