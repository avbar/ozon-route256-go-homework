package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.CheckoutRepository -o ./mocks/checkout_repository_minimock.go -n CheckoutRepositoryMock

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CheckoutRepositoryMock implements domain.CheckoutRepository
type CheckoutRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCheckoutRepositoryMockAddToCart

	funcDeleteFromCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCheckoutRepositoryMockDeleteFromCart

	funcListCart          func(ctx context.Context, user int64) (ca1 []mm_domain.CartItem, err error)
	inspectFuncListCart   func(ctx context.Context, user int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mCheckoutRepositoryMockListCart
}

// NewCheckoutRepositoryMock returns a mock for domain.CheckoutRepository
func NewCheckoutRepositoryMock(t minimock.Tester) *CheckoutRepositoryMock {
	m := &CheckoutRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCheckoutRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CheckoutRepositoryMockAddToCartParams{}

	m.DeleteFromCartMock = mCheckoutRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CheckoutRepositoryMockDeleteFromCartParams{}

	m.ListCartMock = mCheckoutRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*CheckoutRepositoryMockListCartParams{}

	return m
}

type mCheckoutRepositoryMockAddToCart struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockAddToCartExpectation
	expectations       []*CheckoutRepositoryMockAddToCartExpectation

	callArgs []*CheckoutRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockAddToCartExpectation specifies expectation struct of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockAddToCartParams
	results *CheckoutRepositoryMockAddToCartResults
	Counter uint64
}

// CheckoutRepositoryMockAddToCartParams contains parameters of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CheckoutRepositoryMockAddToCartResults contains results of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCheckoutRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CheckoutRepositoryMockAddToCartParams{ctx, user, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCheckoutRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Return(err error) *CheckoutRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CheckoutRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CheckoutRepository.AddToCart method
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CheckoutRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CheckoutRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CheckoutRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CheckoutRepositoryMockAddToCartParams{ctx, user, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockAddToCartExpectation) Then(err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements domain.CheckoutRepository
func (mmAddToCart *CheckoutRepositoryMock) AddToCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, user, sku, count)
	}

	mm_params := &CheckoutRepositoryMockAddToCartParams{ctx, user, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockAddToCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CheckoutRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CheckoutRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, user, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CheckoutRepositoryMock.AddToCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CheckoutRepositoryMock.AddToCart invocations
func (mmAddToCart *CheckoutRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CheckoutRepositoryMock.AddToCart invocations
func (mmAddToCart *CheckoutRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Calls() []*CheckoutRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.AddToCart")
	}
}

type mCheckoutRepositoryMockDeleteFromCart struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockDeleteFromCartExpectation
	expectations       []*CheckoutRepositoryMockDeleteFromCartExpectation

	callArgs []*CheckoutRepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockDeleteFromCartExpectation specifies expectation struct of the CheckoutRepository.DeleteFromCart
type CheckoutRepositoryMockDeleteFromCartExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockDeleteFromCartParams
	results *CheckoutRepositoryMockDeleteFromCartResults
	Counter uint64
}

// CheckoutRepositoryMockDeleteFromCartParams contains parameters of the CheckoutRepository.DeleteFromCart
type CheckoutRepositoryMockDeleteFromCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CheckoutRepositoryMockDeleteFromCartResults contains results of the CheckoutRepository.DeleteFromCart
type CheckoutRepositoryMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepository.DeleteFromCart
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCheckoutRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CheckoutRepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CheckoutRepositoryMockDeleteFromCartParams{ctx, user, sku, count}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.DeleteFromCart
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCheckoutRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CheckoutRepository.DeleteFromCart
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) Return(err error) *CheckoutRepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CheckoutRepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CheckoutRepositoryMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CheckoutRepository.DeleteFromCart method
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CheckoutRepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CheckoutRepository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CheckoutRepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CheckoutRepositoryMockDeleteFromCartParams{ctx, user, sku, count},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockDeleteFromCartExpectation) Then(err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements domain.CheckoutRepository
func (mmDeleteFromCart *CheckoutRepositoryMock) DeleteFromCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, user, sku, count)
	}

	mm_params := &CheckoutRepositoryMockDeleteFromCartParams{ctx, user, sku, count}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockDeleteFromCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CheckoutRepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CheckoutRepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, user, sku, count)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CheckoutRepositoryMock.DeleteFromCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CheckoutRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CheckoutRepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CheckoutRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CheckoutRepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCheckoutRepositoryMockDeleteFromCart) Calls() []*CheckoutRepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.DeleteFromCart")
	}
}

type mCheckoutRepositoryMockListCart struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockListCartExpectation
	expectations       []*CheckoutRepositoryMockListCartExpectation

	callArgs []*CheckoutRepositoryMockListCartParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockListCartExpectation specifies expectation struct of the CheckoutRepository.ListCart
type CheckoutRepositoryMockListCartExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockListCartParams
	results *CheckoutRepositoryMockListCartResults
	Counter uint64
}

// CheckoutRepositoryMockListCartParams contains parameters of the CheckoutRepository.ListCart
type CheckoutRepositoryMockListCartParams struct {
	ctx  context.Context
	user int64
}

// CheckoutRepositoryMockListCartResults contains results of the CheckoutRepository.ListCart
type CheckoutRepositoryMockListCartResults struct {
	ca1 []mm_domain.CartItem
	err error
}

// Expect sets up expected params for CheckoutRepository.ListCart
func (mmListCart *mCheckoutRepositoryMockListCart) Expect(ctx context.Context, user int64) *mCheckoutRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CheckoutRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CheckoutRepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &CheckoutRepositoryMockListCartParams{ctx, user}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.ListCart
func (mmListCart *mCheckoutRepositoryMockListCart) Inspect(f func(ctx context.Context, user int64)) *mCheckoutRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by CheckoutRepository.ListCart
func (mmListCart *mCheckoutRepositoryMockListCart) Return(ca1 []mm_domain.CartItem, err error) *CheckoutRepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CheckoutRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CheckoutRepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &CheckoutRepositoryMockListCartResults{ca1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the CheckoutRepository.ListCart method
func (mmListCart *mCheckoutRepositoryMockListCart) Set(f func(ctx context.Context, user int64) (ca1 []mm_domain.CartItem, err error)) *CheckoutRepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the CheckoutRepository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mCheckoutRepositoryMockListCart) When(ctx context.Context, user int64) *CheckoutRepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CheckoutRepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &CheckoutRepositoryMockListCartParams{ctx, user},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.ListCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockListCartExpectation) Then(ca1 []mm_domain.CartItem, err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockListCartResults{ca1, err}
	return e.mock
}

// ListCart implements domain.CheckoutRepository
func (mmListCart *CheckoutRepositoryMock) ListCart(ctx context.Context, user int64) (ca1 []mm_domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, user)
	}

	mm_params := &CheckoutRepositoryMockListCartParams{ctx, user}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockListCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("CheckoutRepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the CheckoutRepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, user)
	}
	mmListCart.t.Fatalf("Unexpected call to CheckoutRepositoryMock.ListCart. %v %v", ctx, user)
	return
}

// ListCartAfterCounter returns a count of finished CheckoutRepositoryMock.ListCart invocations
func (mmListCart *CheckoutRepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of CheckoutRepositoryMock.ListCart invocations
func (mmListCart *CheckoutRepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mCheckoutRepositoryMockListCart) Calls() []*CheckoutRepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.ListCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CheckoutRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockListCartInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CheckoutRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CheckoutRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockListCartDone()
}
